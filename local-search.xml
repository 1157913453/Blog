<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux Cgroups技术介绍与实践</title>
    <link href="/blog/2022/03/06/Linux-Cgroups%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <url>/blog/2022/03/06/Linux-Cgroups%E6%8A%80%E6%9C%AF%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<p>@[TOC](Linux Cgroups技术介绍与实践)</p><h2 id="什么是Cgroups"><a href="#什么是Cgroups" class="headerlink" title="什么是Cgroups"></a>什么是Cgroups</h2><p><code>Linux Cgroups (Control Groups ）</code>提供了对 组进程及将来子进程的资源限制、控制和统<br>计的能力，这些资源包括 CPU、内存、存储、网络等通过<code>Cgroups</code>，可以方便地限制某个进<br>程的资源占用，并且可以实时地监控进程的监控和统计信息。</p><h3 id="Cgroups中的3个组件"><a href="#Cgroups中的3个组件" class="headerlink" title="Cgroups中的3个组件"></a>Cgroups中的3个组件</h3><ul><li><p><code>cgroup</code>是对进程分组管理的一种机制，<code>cgroup</code>包含一组进程，并可以在这个<code>cgroup</code>上增加<code>Linux subsystem</code>的各种参数配置，将一组进程和<code>subsystem</code>的系统参数关联起来。</p></li><li><p><code>subsystem</code>是一组资源控制的模块，每个<code>subsystem</code>会关联到定义了相应限制的<code>cgroup</code>上，并对这个<code>cgroup</code>中的进程做相应的限制和控制,如限制这个cgroup中的进程的内存数，cpu核心数等</p></li><li><p><code>hierarchy</code>的功能是把<code>cgroup</code>串成一个树状的结构,**一个这样的树便是<code>hierarchy</code>**，通过这种树状结构,<code>Cgroups</code>可以做到继承。比如，系统对一组定时的任务进程通过<code>cgroup</code>限制了<code>CPU</code>的使用率，然后其中有一个定时<code>dump</code>日志的进程还需要限制<code>磁盘IO</code>，为了避免限制了磁盘<code>IO</code>之后影响到其他进程，就可以创建<code>cgroup2</code>，使其继承于<code>cgroup</code>并限制磁盘的<code>IO</code>，这样<code>cgroup2</code>便继承了<code>cgroup1</code>中对<code>CPU</code>使用率的限制，并且增加了<code>磁盘IO</code>的限制而不影响到<code>cgroup1</code>中的其他进程。</p></li></ul><h3 id="三个组件的关系"><a href="#三个组件的关系" class="headerlink" title="三个组件的关系"></a>三个组件的关系</h3><ul><li>系统在创建了新的<code>hierarchy</code>之后，系统中所有的进程都会加入这个 <code>hierarchy cgroup</code>根节点，这个<code>cgroup</code>根节点是<code>hierarchy</code>默认创建的，</li><li>一个<code>subsystem</code>只能附加到一个<code>hierarchy</code>上面</li><li>一个<code>hierarchy</code>可以附加多个<code>subsystem</code></li><li>一个进程可以作为多个<code>cgroup</code>的成员，但是这些<code>cgroup</code>必须在不同的<code>hierarchy</code></li><li>一个进程<code>fork</code>出子进程时，子进程是和父进程在同一个<code>cgroup</code>中的，也可以根据需要将其移动到其他 <code>cgroup</code></li></ul><h2 id="操作Cgroups"><a href="#操作Cgroups" class="headerlink" title="操作Cgroups"></a>操作Cgroups</h2><h3 id="1-创建并挂在一个hierarchy（cgroup树）"><a href="#1-创建并挂在一个hierarchy（cgroup树）" class="headerlink" title="1.创建并挂在一个hierarchy（cgroup树）"></a>1.创建并挂在一个hierarchy（cgroup树）</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">mkdir cgroupTest <span class="hljs-comment">#创建一个hierarchy挂载点</span><br><br>sudo mount -t cgroup -o none,name=cgroupTest cgroupTest ./cgroupTest <span class="hljs-comment">#挂载一个hierarchy</span><br><br>ls cgroupTest <span class="hljs-comment">#挂载后我们就可以看到系统在这个目录下生成了一些默认文件</span><br><br>cgroup.clone_children  cgroup.procs  cgroup.sane_behavior  <br>notify_on_release  release_agent  tasks<br></code></pre></td></tr></table></figure><p>这些文件就是这个<code>hierarchy cgroup</code>根节点的配置项，上面这些文件的含义分别如下。</p><ul><li><p><code>cgroup.clone_children</code>:<code>cpuset</code>的<code>subsystem</code>会读取这个配置文件，如果这个值是1（默认是0），子<code>cgroup</code>才会继承父<code>cgroup</code>的<code>cpuset</code>配置</p></li><li><p><code>cgroup.procs:</code>是树中当前节点<code>cgroup</code>中的进程组<code>ID</code>，现在的位置是在根节点，这个文件中会有现在系统中所有进程组的<code>ID</code></p></li><li><p><code>notify_on _release和release agent</code>会一起使用。<code>notify on release</code>标识当这个<code>cgroup</code>最后一个进程退出的时候是否执行了<code>release_agent</code>;<code>release_ agent</code>则是一个路径，通常用作进程退出之后自动清理掉不再使用的 <code>cgroup</code></p></li><li><p><code>tasks</code>标识<code>cgroup</code>下面的进程<code>ID</code>，如果把一个进程<code>ID</code>写到<code>tasks</code>文件中，便会将相应的进程加入到这个<code>cgroup</code></p></li></ul><h3 id="2-创建hierarchy-cgroup根节点中扩展出的两个子cgroup"><a href="#2-创建hierarchy-cgroup根节点中扩展出的两个子cgroup" class="headerlink" title="2.创建hierarchy cgroup根节点中扩展出的两个子cgroup"></a>2.创建hierarchy cgroup根节点中扩展出的两个子cgroup</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo mkdir cgroup-1 ＃创建子cgroup cgroup-1<br>sudo mkdir cgroup-2 ＃创建子cgroup cgroup-2<br><br>tree<br>.<br>├── cgroup-1<br>│   ├── cgroup.clone_children<br>│   ├── cgroup.procs<br>│   ├── notify_on_release<br>│   └── tasks<br>├── cgroup-2<br>│   ├── cgroup.clone_children<br>│   ├── cgroup.procs<br>│   ├── notify_on_release<br>│   └── tasks<br>├── cgroup.clone_children<br>├── cgroup.procs<br>├── cgroup.sane_behavior<br>├── notify_on_release<br>├── release_agent<br>└── tasks<br></code></pre></td></tr></table></figure><p>可以看到，在<code>cgroup</code>的目录下创建文件夹时，<code>Kernel</code>会把文件夹标记为这个<code>cgroup</code>的子<code>cgroup</code>，它们会继承父<code>cgroup</code>的属性。</p><h3 id="3-cgroup中添加和移动进程"><a href="#3-cgroup中添加和移动进程" class="headerlink" title="3.cgroup中添加和移动进程"></a>3.cgroup中添加和移动进程</h3><p>一个进程在<code>Cgroups hierarchy</code>中，只能在一个<code>cgroup</code>节点上存在，系统的所有进程都会默认在根节点上存在，将进程移动到其他<code>cgroup</code>节点，只需要将进程<code>ID</code>到移动到的<code>cgroup</code>节点的<code>tasks</code>文件中即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> cgroup-1<br><span class="hljs-built_in">echo</span> $$ <span class="hljs-comment">#当前终端的进程id</span><br>27461<br><br>sudo sh -c <span class="hljs-string">&quot;echo $$ &gt;&gt; tasks&quot;</span> <span class="hljs-comment"># 将我所在的终端进程移动到cgroup-1</span><br><br>cat /proc/27461/cgroup<br>15:name=cgroupTest:/cgroup-1<br>14:name=systemd:/<br>13:rdma:/<br>12:pids:/<br>11:hugetlb:/<br>10:net_prio:/<br>9:perf_event:/<br>8:net_cls:/<br>7:freezer:/<br>6:devices:/<br>5:memory:/<br>4:blkio:/<br>3:cpuacct:/<br>2:cpu:/<br>1:cpuset:/<br>0::/<br></code></pre></td></tr></table></figure><p>可以看到， 前的27461进程己经被加到<code>cgroup-test:/cgroup-1</code>中了。</p><h3 id="4-通过subsystem限制cgroup中进程的资源"><a href="#4-通过subsystem限制cgroup中进程的资源" class="headerlink" title="4.通过subsystem限制cgroup中进程的资源"></a>4.通过subsystem限制cgroup中进程的资源</h3><p>在上面创建<code>hierarchy</code>的时候，这个<code>hierarchy</code>并没有关联到任何的<code>subsystem</code>，所以没办法通过那个<code>hierarchy</code>中的<code>cgroup</code>节点限制进程的资源占用，其实系统默认已经为每个<code>subsystem</code>创建了一个默认的<code>hierarchy</code>，比如<code>memory hierarchyo</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">mount | grep memory <span class="hljs-comment">#</span><br>cgroup on /sys/fs/cgroup/memory <span class="hljs-built_in">type</span> cgroup (rw,nosuid,nodev,noexec,relatime,memory)<br></code></pre></td></tr></table></figure><p>可以看到，<code>/sys/fs/cgrou/memory</code>目录便是挂在了<code>memory subsystem hierarchy</code> 上。下面，就通过在这个 <code>hierarchy</code>中创建<code>cgroup</code>，限制如下进程占用的内存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /sys/fs/cgroup/memory<br><span class="hljs-comment"># 首先，在不做限制的情况下，启动一个占用200MB内存的stress进程</span><br>stress --vm-bytes 200m --vm-keep -m 1<br><br><span class="hljs-comment">#这时打开另一个终端输入top命令</span><br><br>  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND<br>31132 root      20   0  208664 204952    272 R 100.0   2.5   0:12.49 stress<br><br><span class="hljs-comment">#可以看到%MEM占用为2.5%，因为我linux系统内存为8GB</span><br><br><span class="hljs-comment">#接下来切换终端回来</span><br><span class="hljs-comment">#创建一个cgroup</span><br>sudo mkdir test-limit-memory &amp;&amp; <span class="hljs-built_in">cd</span> test-limit-memory <br><span class="hljs-comment">#设置该cgroup的最大内存占用为1OOMB</span><br>sudo sh -c <span class="hljs-string">&quot;echo &quot;</span>lOOm<span class="hljs-string">&quot; &gt; memory.limit_in_bytes&quot;</span> <br><span class="hljs-comment">#将当前进程移动到这个 cgroup</span><br>sudo sh -c <span class="hljs-string">&quot;echo $$ &gt; tasks&quot;</span><br><span class="hljs-comment">#再次运行占用内存 200MB stress 进程</span><br>stress --vm-bytes 200m --vm-keep -m 1<br><span class="hljs-comment">#查看刚刚那个运行了top的终端</span><br>  PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND<br>31132 root      20   0  208664  10164    272 R 100.0   1.3   0:12.49 stress<br><br><span class="hljs-comment">#可以看到内存占用变为1.3%,缩小为一半</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读《Docker核心技术与实现原理》文章笔记</title>
    <link href="/blog/2021/12/23/%E8%AF%BB%E3%80%8ADocker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E3%80%8B%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/blog/2021/12/23/%E8%AF%BB%E3%80%8ADocker%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E3%80%8B%E6%96%87%E7%AB%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p><code>Docker</code>采用<code>C/S</code>架构，包括客户端和服务端，<code>Dokcer</code>守护进程<code>Daemon</code>作为服务端接受来自客户端的请求，并处理这些请求（创建、运行、分发容器）</p><p>客户端和服务端可以运行在一个主机上，也能通过<code>socket</code>和<code>RESTful API</code>进行通信</p><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h3 id="命名空间（Namespace）"><a href="#命名空间（Namespace）" class="headerlink" title="命名空间（Namespace）"></a>命名空间（Namespace）</h3><p><code>Linux</code>通过<code>Namespace</code>来实现进程的隔离，<code>Docker</code>容器内部的任意进程对宿主机中的进程一无所知，运行在其中的应用就像独立的操作系统中运行一样。</p><ul><li><strong>pid 命名空间</strong><br>不同用户的进程就是通过pid命名空间隔离开的，且不同命名空间中可以拥有相同的<code>pid</code>。每个容器进程在<code>Docker中</code>的父进程就是<code>Dokcer</code>进程，每个容器进程拥有不同的<code>pid</code>命名空间，且允许嵌套</li></ul><hr><ul><li><strong>net 命名空间</strong><br>每个容器通过net命名空间来实现网络隔离，每个net命名空间拥有独立的网络设备，ip，路由表，/proc/net目录。Docker采用默认的veth方式，将容器中的虚拟网卡同主机host的一个网桥Docker0连接在一起</li></ul><hr><ul><li><strong>ipc 命名空间</strong><br>容器中进程的交互还是采用了<code>Linux常</code>用的进程间交互方式<code>(interprocess communication - IPC)</code>，包括信号量，消息队列，共享内存。容器的进程间交互实际上还是 host 上具有相同<code>pid</code>命名空间中的进程间交互，因此需要在<code>IPC</code>资源申请时加入命名空间信息，每个<code>IPC</code>资源有一个唯一的 32 位 id。</li></ul><hr><ul><li><strong>mnt 命名空间</strong><br>类似<code>chroot</code>，将一个进程放到一个特定的目录执行。mnt 命名空间允许不同命名空间的进程看到的文件结构不同，这样每个命名空间 中的进程所看到的文件目录就被隔离开了。同 <code>chroot </code>不同，每个命名空间中的容器在<code> /proc/mounts</code> 的信息只包含所在命名空间的<code>mount point</code>。</li></ul><hr><ul><li><strong>uts 命名空间</strong><br><code>UTS(&quot;UNIX Time-sharing System&quot;) </code>命名空间允许每个容器拥有独立的 <code>hostname </code>和<code> domain name</code>， 使其在网络上可以被视作一个独立的节点而非 主机上的一个进程。</li></ul><hr><ul><li><strong>user 命名空间</strong><br>每个容器可以拥有不同的用户和组id，也就是说可以在容器内用容器内部的用户执行程序，而非主机上的用户</li></ul><p><strong>因此Docker利用命名空间实现了进程和网络的隔离</strong></p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p>虽然容器通过命名空间实现了网络的隔离，但是却没有办法通过宿主机的网络与互联网连通，会造成很多不便和限制。<code>Docker</code>为我们提供了四种网络配置模式<code>Host、Container、None</code> 和<code>Bridge</code>模式。<br>默认的是网桥<code>（Bridge）</code>模式</p><ul><li><strong>Bridge</strong></li></ul><ol><li>当<code>Docker</code>服务在主机启动后会创建一个虚拟网桥<code>docker0</code>，随后在主机上启动的所有服务默认都会与该网桥相连。</li><li><code>Docker</code>创建一个新容器的时候会创建一对虚拟网卡，一个放到容器中，并改名为eth0，该eth0只在容器的命名空间内可见；</li><li>另一个桥接到<code>docker0</code>网桥上，并具有唯一的名字，如<code>veth7689</code></li><li>从网桥的可用地址中分一个ip地址给容器的<code>eth0</code>，并配置默认路由到网桥<code>docker0</code>的<code>veth7689</code></li></ol><p>可以在<code>docker run</code>的时候通过<code>- -net=</code>参数来指定容器的网络配置，有四个选项：</p><ul><li><strong>–net=bridge</strong><br>这个是默认值，连接到默认的网桥。</li><li><strong>–net=host</strong><br>告诉 <code>Docker </code>不要将容器网络放到隔离的命名空间中，让容器使用本地主机的网络，它拥有完全的本地主机接口访问权限。容器进程可以跟主机其它<code>root</code>进程一样可以打开低范围的端口，可以访问本地网络服务比如 <code>D-bus</code>，还可以让容器做一些影响整个主机系统的事情，比如重启主机。因此使用这个选项的时候要非常小心。如果进一步的使用 <code>--privileged=true</code>，容器会被允许直接配置主机的网络堆栈。</li><li><strong>–net=container:NAME_or_ID</strong><br>让 <code>Docker</code> 将新建容器的进程放到一个已存在容器的网络栈中，新容器进程有自己的文件系统、进程列表和资源限制，但会和已存在的容器共享 <code>IP </code>地址和端口等网络资源，两者进程可以直接通过 lo 环回接口通信。</li><li><strong>–net=none</strong><br>让 <code>Docker</code> 将新容器放到隔离的网络栈中，但是不进行网络配置。之后，用户可以自己进行配置。</li></ul><h1 id="CGroups"><a href="#CGroups" class="headerlink" title="CGroups"></a>CGroups</h1><p>倘若其中的某一个容器正在执行 <code>CPU </code>密集型的任务，那么就会影响其他容器中任务的性能与执行效率，导致多个容器相互影响并且抢占资源，因此<code>Docker</code>通过<code>CGroups</code>技术隔离主机上的物理资源，如CPU、内存、磁盘<code> I/O</code> 和网络带宽等。</p><p>每一个<code> CGroup</code> 都是一组被相同的标准和参数限制的进程，不同的 <code>CGroup</code> 之间是有层级关系的，可以继承。在<code> CGroup</code> 这种机制中，所有的资源控制都是以<code>CGroup</code>作为单位实现的，每一个进程都可以随时加入和退出一个 <code>CGroup</code>。</p><h1 id="UnionFS"><a href="#UnionFS" class="headerlink" title="UnionFS"></a>UnionFS</h1><p>联合文件系统<code>UnionFS</code>是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下.</p><p>目前版本的的<code>Docker</code>默认使用<code>overlay2</code>存储驱动，之前是<code>aufs</code></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言使用golang-jwt/jwt/v4进行JWT鉴权</title>
    <link href="/blog/2021/12/22/Go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8golang-jwt-jwt-v4%E8%BF%9B%E8%A1%8CJWT%E9%89%B4%E6%9D%83/"/>
    <url>/blog/2021/12/22/Go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8golang-jwt-jwt-v4%E8%BF%9B%E8%A1%8CJWT%E9%89%B4%E6%9D%83/</url>
    
    <content type="html"><![CDATA[<p>@[TOC]</p><p>最近写的项目中用到了<code>JWT</code>鉴权，因此做个记录<br>原先的<code>jwt-go</code>仓库已经不再维护，迁移到了<code>github.com/golang-jwt/jwt/v4</code><br>但是网上大多数还是<code>v3</code>版本的使用教程，建议使用更加安全的<code>v4</code></p><h2 id="1-什么是JWT"><a href="#1-什么是JWT" class="headerlink" title="1.什么是JWT"></a>1.什么是JWT</h2><blockquote><p><strong>JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</strong></p></blockquote><h2 id="2-JWT的数据结构"><a href="#2-JWT的数据结构" class="headerlink" title="2.JWT的数据结构"></a>2.JWT的数据结构</h2><p>实际的<code>JWT</code>由三部分组成，如下图<br><img src="https://img-blog.csdnimg.cn/img_convert/f1227b67b9cdee2ea80abeecd2b5e6d5.png"></p><p>中间用点（<code>.</code>）分隔成三个部分。注意，<code>JWT</code> 内部是没有换行的，这里只是为了便于展示，将它写成了几行。JWT的三个部分依次如下：</p><ul><li><code>Header</code>（头部）</li><li><code>Payload</code>（负载）</li><li><code>Signature</code>（签名）</li></ul><p>写成一行就是<code>Header.Payload.Signature</code></p><hr><p><img src="https://img-blog.csdnimg.cn/img_convert/5ada979e7737d871e8abcd4175a6a462.png"></p><hr><h3 id="2-1-Header"><a href="#2-1-Header" class="headerlink" title="2.1 Header"></a>2.1 Header</h3><p><code>Header</code> 部分是一个 <code>JSON</code> 对象，描述 <code>JWT</code> 的元数据，通常是下面的样子</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs go">&#123;<br>  <span class="hljs-string">&quot;alg&quot;</span>: <span class="hljs-string">&quot;HS256&quot;</span>,<br>  <span class="hljs-string">&quot;typ&quot;</span>: <span class="hljs-string">&quot;JWT&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>alg</code>属性表示签名的算法（<code>algorithm</code>），默认是<code>HMAC SHA256</code>（写成 <code>HS256</code>）；<code>typ</code>属性表示这个令牌（<code>token</code>）的类型（<code>type</code>），<code>JWT</code> 令牌统一写为<code>JWT</code>。</p><p>将上面的 <code>JSON</code> 对象使用 <code>Base64URL</code> 算法（详见后文）转成字符串就成了第一部分<code>Header</code>。</p><h3 id="2-2-Payload"><a href="#2-2-Payload" class="headerlink" title="2.2 Payload"></a>2.2 Payload</h3><p><code>Payload</code> 部分也是一个 <code>JSON</code> 对象，用来存放实际需要传递的数据。<code>JWT</code> 规定了7个官方字段，供选用。</p><ul><li><code>iss (issuer)</code>：签发人</li><li><code>exp (expiration time)</code>：过期时间</li><li><code>sub (subject)</code>：主题</li><li><code>aud (audience)</code>：受众</li><li><code>nbf (Not Before)</code>：生效时间</li><li><code>iat (Issued At)</code>：签发时间</li><li><code>jti (JWT ID)</code>：编号</li></ul><p>我们还可以在这个部分自己定义字段，下面就是一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">&#123;<br>  <span class="hljs-string">&quot;sub&quot;</span>: <span class="hljs-string">&quot;1234567890&quot;</span>,<br>  <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;John Doe&quot;</span>,<br>  <span class="hljs-string">&quot;admin&quot;</span>: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，<code>JWT</code> 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 <code>JSON</code> 对象也要使用 <code>Base64URL</code> 算法转成字符串。</p><h3 id="2-3-Signature"><a href="#2-3-Signature" class="headerlink" title="2.3 Signature"></a>2.3 Signature</h3><p><code>Signature</code> 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（<code>secret</code>）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 <code>Header</code> 里面指定的签名算法（默认是 <code>HMAC SHA256</code>），按照下面的公式产生签名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">HMACSHA256(<br>  base64UrlEncode(header) + <span class="hljs-string">&quot;.&quot;</span> +<br>  base64UrlEncode(payload),<br>  secret)<br></code></pre></td></tr></table></figure><h3 id="2-4-Base64URL"><a href="#2-4-Base64URL" class="headerlink" title="2.4 Base64URL"></a>2.4 Base64URL</h3><p>前面提到，<code>Header</code> 和 <code>Payload</code> 串型化的算法是 <code>Base64URL</code>。这个算法跟 <code>Base64</code> 算法基本类似，但有一些小的不同。</p><p><code>JWT</code> 作为一个令牌（<code>token</code>），有些场合可能会放到 <code>URL</code>（比如 api.example.com/?token=xxx）。<code>Base64</code> 有三个字符+，/和=，在 <code>URL</code> 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 <code>Base64URL</code> 算法。</p><p>算出签名以后，把 <code>Header</code>、<code>Payload</code>、<code>Signature</code> 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p><h2 id="3使用JWT"><a href="#3使用JWT" class="headerlink" title="3使用JWT"></a>3使用JWT</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get -u <span class="hljs-string">&quot;github.com/golang-jwt/jwt/v4&quot;</span><br></code></pre></td></tr></table></figure><h3 id="生成Token"><a href="#生成Token" class="headerlink" title="生成Token"></a>生成Token</h3><p>定义<code>claims</code>和<code>serect</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyClaims <span class="hljs-keyword">struct</span> &#123;<br>Phone <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;phone&quot;`</span><br>jwt.RegisteredClaims  <span class="hljs-comment">// 注意!这是jwt-go的v4版本新增的，原先是jwt.StandardClaims</span><br>&#125;<br><br><span class="hljs-keyword">var</span> MySecret = []<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;手写的从前&quot;</span>) <span class="hljs-comment">// 定义secret，后面会用到</span><br></code></pre></td></tr></table></figure><p>生成<code>token</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 这里传入的是手机号，因为我项目登陆用的是手机号和密码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeToken</span><span class="hljs-params">(phone <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(tokenString <span class="hljs-keyword">string</span>, err error)</span></span> &#123;<br>claim := MyClaims&#123;<br>Phone: phone,<br>RegisteredClaims: jwt.RegisteredClaims&#123;<br>ExpiresAt: jwt.NewNumericDate(time.Now().Add(<span class="hljs-number">3</span> * time.Hour * time.Duration(<span class="hljs-number">1</span>))), <span class="hljs-comment">// 过期时间3小时</span><br>IssuedAt:  jwt.NewNumericDate(time.Now()),     <span class="hljs-comment">// 签发时间</span><br>NotBefore: jwt.NewNumericDate(time.Now()),     <span class="hljs-comment">// 生效时间</span><br>&#125;&#125;<br>token := jwt.NewWithClaims(jwt.SigningMethodHS256, claim) <span class="hljs-comment">// 使用HS256算法</span><br>tokenString, err = token.SignedString(MySecret)<br><span class="hljs-keyword">return</span> tokenString, err<br>&#125;<br></code></pre></td></tr></table></figure><p>解析<code>token</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Secret</span><span class="hljs-params">()</span> <span class="hljs-title">jwt</span>.<span class="hljs-title">Keyfunc</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(token *jwt.Token)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span> &#123;<br><span class="hljs-keyword">return</span> []<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;手写的从前&quot;</span>), <span class="hljs-literal">nil</span>  <span class="hljs-comment">// 这是我的secret</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseToken</span><span class="hljs-params">(tokenss <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(*MyClaims, error)</span></span> &#123;<br>token, err := jwt.ParseWithClaims(tokenss, &amp;MyClaims&#123;&#125;, Secret())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> ve, ok := err.(*jwt.ValidationError); ok &#123;<br><span class="hljs-keyword">if</span> ve.Errors&amp;jwt.ValidationErrorMalformed != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;that&#x27;s not even a token&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ve.Errors&amp;jwt.ValidationErrorExpired != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;token is expired&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ve.Errors&amp;jwt.ValidationErrorNotValidYet != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;token not active yet&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;couldn&#x27;t handle this token&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> claims, ok := token.Claims.(*MyClaims); ok &amp;&amp; token.Valid &#123;<br><span class="hljs-keyword">return</span> claims, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;couldn&#x27;t handle this token&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><p><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">JSON Web Token 入门教程</a></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>JWT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用容器搭建MySQL8.0的主从复制</title>
    <link href="/blog/2021/12/16/%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BAMySQL8-0%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <url>/blog/2021/12/16/%E4%BD%BF%E7%94%A8%E5%AE%B9%E5%99%A8%E6%90%AD%E5%BB%BAMySQL8-0%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="首先启动两个容器"><a href="#首先启动两个容器" class="headerlink" title="首先启动两个容器"></a>首先启动两个容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 主数据库</span><br>docker run -itd --name mysql-master -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql<br><br><span class="hljs-comment">## 从数据库</span><br>docker run -itd --name mysql-slave -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql<br></code></pre></td></tr></table></figure><h3 id="配置master"><a href="#配置master" class="headerlink" title="配置master"></a>配置master</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it mysql-master bash <span class="hljs-comment">## 进入容器</span><br><br><span class="hljs-built_in">cd</span> /etc/mysql <br><br><span class="hljs-comment">## 以下两步安装vim</span><br>apt-get update<br><br>apt-get install vim<br><br><span class="hljs-comment">## 编辑my.cnf文件</span><br>vim my.cnf<br><br><br>[mysqld]<br><span class="hljs-comment">## 同一局域网内注意要唯一，如待会要配置的slave节点可设置成101</span><br>server-id=100  <br><span class="hljs-comment">## 开启二进制日志功能，可以随便取（关键）</span><br>log-bin=master-bin<br>binlog-format=ROW     // 二级制日志格式，有三种 row，statement，mixed<br>binlog-do-db=数据库名  //同步的数据库名称,如果不配置，表示同步所有的库<br></code></pre></td></tr></table></figure><p>配置完成后，<code>exit</code>命令退出<code>docker</code>容器，重启容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker restart mysql-master<br></code></pre></td></tr></table></figure><h3 id="配置slave"><a href="#配置slave" class="headerlink" title="配置slave"></a>配置slave</h3><p>前面步骤都一样，只是最终把<code>my.cnf</code>设置成如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">[mysqld]<br><span class="hljs-comment">## 设置server_id,注意要唯一</span><br>server-id=101  <br><span class="hljs-comment">## 开启二进制日志功能，以备Slave作为其它Slave的Master时使用</span><br>log-bin=mysql-slave-bin   <br><span class="hljs-comment">## relay_log配置中继日志</span><br>relay_log=mysql-relay-bin  <br>read_only=1  <span class="hljs-comment">## 设置为只读,该项如果不设置，表示slave可读可写</span><br></code></pre></td></tr></table></figure><p>配置完成后，<code>exit</code>命令退出<code>docker</code>容器，重启容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker restart mysql-slave<br></code></pre></td></tr></table></figure><h3 id="开启主从复制"><a href="#开启主从复制" class="headerlink" title="开启主从复制"></a>开启主从复制</h3><p>首先查看主库<code>root</code>的<code>plugin</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">SELECT plugin FROM `user` <span class="hljs-built_in">where</span> user = <span class="hljs-string">&#x27;root&#x27;</span>;<br></code></pre></td></tr></table></figure><p>如果输出是<code>caching_sha2_password</code>的话会出问题，因此要修改为<code>mysql_native_password</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ALTER USER <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED WITH mysql_native_password BY <span class="hljs-string">&#x27;root&#x27;</span>;<br></code></pre></td></tr></table></figure><p>进入Master库mysql客户端：输入<code>show master status</code>查看<code>Master</code>状态：<br><img src="https://img-blog.csdnimg.cn/9d16fae5a3e9402cb86b62798fcf9e18.png" alt="在这里插入图片描述"><br>记住<code>File</code>和<code>Position</code>，后面需要用到。此时一定不要操作<code>Master</code>库，否则将会引起Master状态的变化，<code>File</code>和<code>Position</code>字段也将会进行变化。<br><code>master_host ：Maste</code>r库的地址，指的是容器的独立ip,可以通过<br><code>docker inspect --format=&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#39; </code>容器名称 | 容器id查询容器的IP进行查询：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker inspect --format=<span class="hljs-string">&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27;</span> mysql-master<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">172.17.0.2<br></code></pre></td></tr></table></figure><p><strong>进入到Slave库myslq客户端，执行如下命令,记得修改为自己的参数</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">change master to master_host=<span class="hljs-string">&#x27;172.17.0.2&#x27;</span>, master_user=<span class="hljs-string">&#x27;root&#x27;</span>, master_password=<span class="hljs-string">&#x27;123456&#x27;</span>, master_port=3306, master_log_file=<span class="hljs-string">&#x27;master-bin.000002&#x27;</span>, master_log_pos=443, master_connect_retry=30;<br></code></pre></td></tr></table></figure><p><code>master_host</code> ：Master库的地址，指的是容器的独立ip,可以通过<br><code>docker inspect --format=&#39;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#39;</code> 容器名称 | 容器id查询容器的IP进行查询：<br><code>master_port</code>：Master的端口号，指的是容器的端口号<br><code>master_user</code>：用于数据同步的用户<br><code>master_password</code>：用于同步的用户的密码<br><code>master_log_file</code>：指定 Slave 从哪个日志文件开始复制数据，即上文中提到的 File 字段的值<br><code>master_log_pos</code>：从哪个 Position 开始读，即上文中提到的 Position 字段的值<br><code>master_connect_retry</code>：如果连接失败，重试的时间间隔，单位是秒，默认是60秒</p><p>启动slave:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">start slave<br></code></pre></td></tr></table></figure><p>查询slave状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">show slave status\G;<br></code></pre></td></tr></table></figure><p>如果其中的<code>Slave_IO_Running</code>是<code>Connecting</code>说明主从复制一直处于连接状态，必须要两个都是<code>Yes</code>才行。<br><img src="https://img-blog.csdnimg.cn/c84f57fdd2554ba28f9257eb1338bfe8.png" alt="在这里插入图片描述"><br>我们可以根据 <code>Last_IO_Error</code>提示，利用搜索引擎搜索对应问题予以排除。<br><img src="https://img-blog.csdnimg.cn/7e35f04a9be5453191825d3a6ec54910.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r6Iqx5rW3,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在主mysql创建hangzhou数据库：<br><img src="https://img-blog.csdnimg.cn/212783c7ac424708aee06165013a5e0a.png" alt="在这里插入图片描述"></p><p>进入从数据库的容器中查看<br><img src="https://img-blog.csdnimg.cn/6808bf1954b248e0ba171ecd5405bcf0.png" alt="在这里插入图片描述"><br>发现已经同步</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/qq_40942490/article/details/109158285">Docker搭建MySQL8主从复制 （全网最详细版）</a></p><p><a href="https://blog.csdn.net/u012483153/article/details/114484769">MySQL主从复制报错Authentication plugin ‘caching_sha2_password‘ reported error: Authentication</a></p>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>容器</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录工作中使用sqlmock和gorm遇到的一些问题</title>
    <link href="/blog/2021/12/13/%E8%AE%B0%E5%BD%95%E5%B7%A5%E4%BD%9C%E4%B8%AD%E4%BD%BF%E7%94%A8sqlmock%E5%92%8Cgorm%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <url>/blog/2021/12/13/%E8%AE%B0%E5%BD%95%E5%B7%A5%E4%BD%9C%E4%B8%AD%E4%BD%BF%E7%94%A8sqlmock%E5%92%8Cgorm%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><ul><li>sqlmock中默认使用的是正则表达式去匹配sql语句<br>如<code>sqlmock.ExpectQuery()</code>和<code>sqlmock.ExpectExec()</code>等，如果想直接匹配sql语句需要加上<code>regexp.QuoteMeta()</code><br>例子:<figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//这个是使用正则来匹配sql语句，需要使用“\\”来转义字符</span><br>mock.ExpectQuery(<span class="hljs-string">&quot;SELECT \\* FROM `cmdb_app` WHERE app_code = \\? AND is_deleted = \\? ORDER BY `cmdb`\\.`id` limit 1&quot;</span>)<br><span class="hljs-comment">//直接匹配sql语句</span><br>mock.ExpectQuery(regexp.QuoteMeta(<span class="hljs-string">&quot;SELECT * FROM `cmdb_app` WHERE app_code = ? AND is_deleted = ? ORDER BY `cmdb`.`id` limit 1&quot;</span>))<br></code></pre></td></tr></table></figure></li></ul><h3 id="mock所有的sql语句"><a href="#mock所有的sql语句" class="headerlink" title="mock所有的sql语句"></a>mock所有的sql语句</h3><p>当我想测试一个在mysql中创建app记录的函数时，我只模拟了insert语句的返回情况，忽略了创建app记录前还有个select语句判断当前数据库中是否已有app记录<br>当前的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">mock.ExpectBegin()<br>mock.ExpectExec(<span class="hljs-string">&quot;INSERT INTO&quot;</span>).WillReturnResult(sqlmock.NewResult(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>mock.ExpectCommit()<br></code></pre></td></tr></table></figure><p>所以导致了下面这个错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">call to Query <span class="hljs-string">&#x27;SELECT * FROM `cmdb_app` WHERE app_code = ? and is_deleted = 0 ORDER BY `cmdb_app`.`id` LIMIT 1&#x27;</span> with args [&#123;Name: Ordinal:<span class="hljs-number">1</span> Value:app1&#125;], was not expected, next expectation is: ExpectedExec =&gt; expecting Exec or ExecContext which:<br>  - matches sql: <span class="hljs-string">&#x27;INSERT INTO&#x27;</span><br>  - is without arguments<br>  - should <span class="hljs-keyword">return</span> Result having:<br>      LastInsertId: <span class="hljs-number">1</span><br>      RowsAffected: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>修改代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 在mock.ExpectExec(&quot;INSERT INTO&quot;)之前加上下面代码</span><br>mock.ExpectQuery(<span class="hljs-string">&quot;SELECT&quot;</span>).WillReturnRows(sqlmock.NewRows([]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;app_code&quot;</span>, <span class="hljs-string">&quot;app_name&quot;</span>, <span class="hljs-string">&quot;status&quot;</span>, <span class="hljs-string">&quot;business&quot;</span>, <span class="hljs-string">&quot;app_type&quot;</span>, <span class="hljs-string">&quot;desc&quot;</span>, <span class="hljs-string">&quot;language&quot;</span>&#125;))<br></code></pre></td></tr></table></figure><p>运行成功：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">=== RUN   TestCreateApp<br>--- PASS: TestCreateApp (<span class="hljs-number">0.00</span>s)<br>=== RUN   TestCreateApp/create_success<br>    --- PASS: TestCreateApp/create_success (<span class="hljs-number">0.00</span>s)<br>PASS<br></code></pre></td></tr></table></figure><h3 id="注意关闭内联优化"><a href="#注意关闭内联优化" class="headerlink" title="注意关闭内联优化"></a>注意关闭内联优化</h3><p>有时会遇到mock失效的情况，这个问题一般是内联导致的。</p><p><strong>什么是内联？</strong></p><p>为了减少函数调用时的堆栈等开销，对于简短的函数，会在编译时，直接内嵌调用的代码。<br>如下面例子未使用内联优化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">[root@DESKTOP-GG9HG4Q cmdb_service]# <span class="hljs-keyword">go</span> test <br>E<br>Errors:<br>  * /root/Projections/Athena/src/service/cmdb_service/cmdb_environment_test.<span class="hljs-keyword">go</span> <br>  Line <span class="hljs-number">167</span>: - runtime error: invalid memory address or <span class="hljs-literal">nil</span> pointer dereference <br>  goroutine <span class="hljs-number">8</span> [running]:<br>        /home/gopath/pkg/mod/github.com/smartystreets/goconvey@v1<span class="hljs-number">.6</span><span class="hljs-number">.4</span>/convey/reporting/reports.<span class="hljs-keyword">go</span>:<span class="hljs-number">148</span> +<span class="hljs-number">0x6f</span><br>        /home/gopath/pkg/mod/github.com/smartystreets/goconvey@v1<span class="hljs-number">.6</span><span class="hljs-number">.4</span>/convey/reporting/reports.<span class="hljs-keyword">go</span>:<span class="hljs-number">121</span> +<span class="hljs-number">0x75</span><br>        /home/gopath/pkg/mod/github.com/smartystreets/goconvey@v1<span class="hljs-number">.6</span><span class="hljs-number">.4</span>/convey/context.<span class="hljs-keyword">go</span>:<span class="hljs-number">235</span> +<span class="hljs-number">0x13f</span><br></code></pre></td></tr></table></figure><p> 加上<code>-gcflags=all=-l</code>后关闭内联优化<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"> [root@DESKTOP-GG9HG4Q cmdb_service]# <span class="hljs-keyword">go</span> test -gcflags=all=-l<br>.<br><span class="hljs-number">1</span> total assertion<br><br>PASS<br>ok      athena/src/service/cmdb_service <span class="hljs-number">0.005</span>s<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>sqlmock</tag>
      
      <tag>测试</tag>
      
      <tag>gorm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go的常用设计模式</title>
    <link href="/blog/2021/12/10/Go%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/blog/2021/12/10/Go%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>好记性不如烂笔头，学习编程的最好方式就是自己把代码动手敲一遍</p><h2 id="1-策略模式（strategy）"><a href="#1-策略模式（strategy）" class="headerlink" title="1.策略模式（strategy）"></a>1.策略模式（strategy）</h2><p>在实际应用中， 我们对不同的场景要采取不同的应对措施，也就是不同的策略。定义一个接口，传入的不同对象实现了接口，因此自动调用对应的策略<br>其中strategy.go:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml">package strategy<br><br>import <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Payment <span class="hljs-keyword">struct</span> &#123;<br>payctx   *PayCtx<br>strategy Strategy<br>&#125;<br><br><span class="hljs-keyword">type</span> Strategy interface &#123;<br><span class="hljs-constructor">Pay(<span class="hljs-operator">*</span>PayCtx)</span><br>&#125;<br><br><span class="hljs-keyword">type</span> PayCtx <span class="hljs-keyword">struct</span> &#123;<br>money <span class="hljs-built_in">int</span><br>name  <span class="hljs-built_in">string</span><br>&#125;<br><br>func <span class="hljs-constructor">NewPayment(<span class="hljs-params">money</span> <span class="hljs-params">int</span>, <span class="hljs-params">name</span> <span class="hljs-params">string</span>, <span class="hljs-params">strategy</span> Strategy)</span> *Payment &#123;<br>return &amp;Payment&#123;<br>payctx: &amp;PayCtx&#123;<br>money: money,<br>name:  name,<br>&#125;,<br>strategy: strategy,<br>&#125;<br>&#125;<br><br>func (p *Payment) <span class="hljs-constructor">Pay()</span> &#123;<br>p.strategy.<span class="hljs-constructor">Pay(<span class="hljs-params">p</span>.<span class="hljs-params">payctx</span>)</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Cash <span class="hljs-keyword">struct</span>&#123;&#125;<br><br>func (cash *Cash) <span class="hljs-constructor">Pay(<span class="hljs-params">ctx</span> <span class="hljs-operator">*</span>PayCtx)</span> &#123;<br>fmt.<span class="hljs-constructor">Printf(<span class="hljs-string">&quot;%s使用现金支付了%d\n&quot;</span>, <span class="hljs-params">ctx</span>.<span class="hljs-params">name</span>, <span class="hljs-params">ctx</span>.<span class="hljs-params">money</span>)</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Bank <span class="hljs-keyword">struct</span>&#123;&#125;<br><br>func (bank *Bank) <span class="hljs-constructor">Pay(<span class="hljs-params">ctx</span> <span class="hljs-operator">*</span>PayCtx)</span> &#123;<br>fmt.<span class="hljs-constructor">Printf(<span class="hljs-string">&quot;%s使用银行支付了%d\n&quot;</span>, <span class="hljs-params">ctx</span>.<span class="hljs-params">name</span>, <span class="hljs-params">ctx</span>.<span class="hljs-params">money</span>)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码strategy_test.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> strategy<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNewPayment</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>a := NewPayment(<span class="hljs-number">18</span>, <span class="hljs-string">&quot;zr&quot;</span>, &amp;Cash&#123;&#125;)<br>b := NewPayment(<span class="hljs-number">9090</span>, <span class="hljs-string">&quot;sys&quot;</span>, &amp;Bank&#123;&#125;)<br><br>a.Pay()<br>b.Pay()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单例模式（singleton）"><a href="#单例模式（singleton）" class="headerlink" title="单例模式（singleton）"></a>单例模式（singleton）</h2><p>许多时候软件内只需要一个实例对象，此时便可用单例模式创建此对象；<br>单例模式算是go中实现最简单的了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> s *Singleton<br><span class="hljs-keyword">var</span> once sync.Once<br><br><span class="hljs-keyword">type</span> Singleton <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetSingleton</span><span class="hljs-params">()</span> *<span class="hljs-title">Singleton</span></span> &#123;<br>once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>s = &amp;Singleton&#123;&#125;<br>&#125;)<br><br><span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>测试singleton_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGetSingleton</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-number">1000</span>)<br>start := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>arr := <span class="hljs-built_in">make</span>([]*Singleton, <span class="hljs-number">1000</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br><span class="hljs-comment">//同时起1000个goroutine</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(index <span class="hljs-keyword">int</span>)</span></span> &#123;<br>&lt;-start <span class="hljs-comment">// 全部阻塞在此</span><br>singleton := GetSingleton() <span class="hljs-comment">// 获取单例对象</span><br>arr[index] = singleton<br>wg.Done() <span class="hljs-comment">// 将每个goroutine获得的单例对象存储到数组</span><br>&#125;(i)<br>&#125;<br><span class="hljs-built_in">close</span>(start) <span class="hljs-comment">// 关闭通道的同时，1000个goroutine同时执行</span><br>wg.Wait()    <span class="hljs-comment">// 阻塞等待所有goroutine执行完成</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">999</span>; i++ &#123;<br><span class="hljs-keyword">if</span> arr[i] != arr[i+<span class="hljs-number">1</span>] &#123;<br>t.Fatalf(<span class="hljs-string">&quot;同时有多个实例&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="简单工厂模式（simple-factory）"><a href="#简单工厂模式（simple-factory）" class="headerlink" title="简单工厂模式（simple_factory）"></a>简单工厂模式（simple_factory）</h2><p>当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> simple_factory<br><br><span class="hljs-keyword">type</span> Production <span class="hljs-keyword">interface</span> &#123;<br>create() <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Factory <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *Factory)</span> <span class="hljs-title">NewProduction</span><span class="hljs-params">(name <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">Production</span></span> &#123;<br><span class="hljs-keyword">switch</span> name &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-keyword">return</span> &amp;Product1&#123;&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-keyword">return</span> &amp;Product2&#123;&#125;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> Product1 <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Product1)</span> <span class="hljs-title">create</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;产品1&quot;</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Product2 <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Product2)</span> <span class="hljs-title">create</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;产品2&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码simeple_factory_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> simple_factory<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFactory_NewProduction</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>factory := Factory&#123;&#125;<br>production1 := factory.NewProduction(<span class="hljs-number">1</span>)<br>production2 := factory.NewProduction(<span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">if</span> production1.create() != <span class="hljs-string">&quot;产品1&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;产品1测试失败&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> production2.create() != <span class="hljs-string">&quot;产品2&quot;</span> &#123;<br>t.Fatalf(<span class="hljs-string">&quot;产品2测试失败&quot;</span>)<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式用于触发联动。</p><p>subject的改变会触发他所有观察者的相关动作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> observer<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> IObserver <span class="hljs-keyword">interface</span> &#123;<br>Notify()<br>&#125;<br><br><span class="hljs-keyword">type</span> ISubject <span class="hljs-keyword">interface</span> &#123;<br>AddObserver(observer ...IObserver)<br>NotifyObserver()<br>&#125;<br><br><span class="hljs-keyword">type</span> Observer <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-keyword">type</span> Subject <span class="hljs-keyword">struct</span> &#123;<br>OArr []IObserver<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewObserver</span><span class="hljs-params">()</span> *<span class="hljs-title">Observer</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;Observer&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSubject</span><span class="hljs-params">()</span> *<span class="hljs-title">Subject</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;Subject&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Observer)</span> <span class="hljs-title">Notify</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;执行命令&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Subject)</span> <span class="hljs-title">AddObserver</span><span class="hljs-params">(observer ...IObserver)</span></span> &#123;<br>s.OArr = <span class="hljs-built_in">append</span>(s.OArr, observer...)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Subject)</span> <span class="hljs-title">NotifyObserver</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s.OArr &#123;<br>v.Notify()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码observer_test.go:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> observer<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestObserver_Notify</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>observer := NewObserver()<br>subject := NewSubject()<br>subject.AddObserver(observer)<br>subject.NotifyObserver()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL2安装CentOS7和Xfce4桌面</title>
    <link href="/blog/2021/12/05/WSL2%E5%AE%89%E8%A3%85CentOS7%E5%92%8CXfce4%E6%A1%8C%E9%9D%A2/"/>
    <url>/blog/2021/12/05/WSL2%E5%AE%89%E8%A3%85CentOS7%E5%92%8CXfce4%E6%A1%8C%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>由于工作和学习需要，需要在WSL中安装和配置CentOS7系统</p><h2 id="1-安装和升级WSL"><a href="#1-安装和升级WSL" class="headerlink" title="1.安装和升级WSL"></a>1.安装和升级WSL</h2><p>安装和升级WSL方法可看<a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10">微软官方教程</a><br>本人是将电脑中的WSL升级到了WSL2</p><h2 id="2-下载安装CentOS镜像"><a href="#2-下载安装CentOS镜像" class="headerlink" title="2.下载安装CentOS镜像"></a>2.下载安装CentOS镜像</h2><p>首先需要下载CentOS7镜像，下面两个网站都可下载CentOS镜像，选择其中一个进行下载即可<br><a href="https://github.com/mishamosher/CentOS-WSL/releases">https://github.com/mishamosher/CentOS-WSL/releases</a><br><a href="https://github.com/wsldl-pg/CentWSL/releases">https://github.com/wsldl-pg/CentWSL/releases</a><br>本人下载的是其中CentOS7的最新版本<br>解压出来后双击其中的CentOS7.exe，静静等待安装完成即可</p><h2 id="3-安装Xfce4桌面"><a href="#3-安装Xfce4桌面" class="headerlink" title="3.安装Xfce4桌面"></a>3.安装Xfce4桌面</h2><h4 id="1-安装Xfce4"><a href="#1-安装Xfce4" class="headerlink" title="1.安装Xfce4"></a>1.安装Xfce4</h4><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">sudo yum install -y epel-release<br><br>sudo yum groupinstall -y <span class="hljs-string">&quot;Xfce&quot;</span><br></code></pre></td></tr></table></figure><ul><li><p>如果遇到报错<code>Error getting repository data for epel, repository not found</code>,报错原因：</p><blockquote><p>系统中未启用 RHEL/CentOS 7.x/6.x/5.x 的 EPEL 存储库。<br>EPEL 代表企业 Linux 及其在线分布式的额外软件包，可以由 yum 程序自动下载和安装。<br>只要启用了此选项，错误就会解决</p></blockquote></li><li><p>解决办法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果没有安装 wget 需要先  yum install wget</span><br>wget http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm<br>rpm -ivh epel-release-latest-7.noarch.rpm<br></code></pre></td></tr></table></figure></li></ul><h4 id="2-重启WSL"><a href="#2-重启WSL" class="headerlink" title="2.重启WSL"></a>2.重启WSL</h4><p>在powershell中执行下面命令</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl -<span class="hljs-literal">-shutdonw</span><br></code></pre></td></tr></table></figure><h4 id="3-Win10安装VcXsrv，启动VcXsrv"><a href="#3-Win10安装VcXsrv，启动VcXsrv" class="headerlink" title="3.Win10安装VcXsrv，启动VcXsrv"></a>3.Win10安装VcXsrv，启动VcXsrv</h4><p>直接默认配置，但是第三页设置为下图：<br><img src="https://img-blog.csdnimg.cn/84043b4ce7b148f3a1f6f9659f14431f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5p6r6Iqx5rW3,size_19,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p><h2 id="4-配置Xfce4"><a href="#4-配置Xfce4" class="headerlink" title="4.配置Xfce4"></a>4.配置Xfce4</h2><p><code>vi ~/.bashrc</code>打开<code>bashrc</code>文件在最后面加上下面代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> windows_host=`ipconfig.exe | grep -n4 WSL | tail -n 1 | awk -F<span class="hljs-string">&quot;:&quot;</span> <span class="hljs-string">&#x27;&#123; print $2 &#125;&#x27;</span> | sed <span class="hljs-string">&#x27;s/^[ \r\n\t]*//;s/[ \r\n\t]*$//&#x27;</span>`<br><br><span class="hljs-built_in">export</span> DISPLAY=<span class="hljs-variable">$windows_host</span>:0x<br></code></pre></td></tr></table></figure><p>最后执行<code>startxfce4</code>就行了</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>CentOS7</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过casbin实现RBAC权限设计(Mysql存储Policy)</title>
    <link href="/blog/2021/12/01/%E9%80%9A%E8%BF%87casbin%E5%AE%9E%E7%8E%B0RBAC%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1-Mysql%E5%AD%98%E5%82%A8Policy/"/>
    <url>/blog/2021/12/01/%E9%80%9A%E8%BF%87casbin%E5%AE%9E%E7%8E%B0RBAC%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1-Mysql%E5%AD%98%E5%82%A8Policy/</url>
    
    <content type="html"><![CDATA[<p><a href="https://casbin.org/docs/zh-CN/get-started">casbin官网</a><br>简单记录下casbin的练手</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>截至<code>2021.11.29</code>日，<code>casbin</code>的最新版本为<code>v2</code></p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">go get github.com/casbin/casbin/v2<br></code></pre></td></tr></table></figure><h3 id="编写模型文件model-conf"><a href="#编写模型文件model-conf" class="headerlink" title="编写模型文件model.conf"></a>编写模型文件<code>model.conf</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">[role_definition]<br>g = _, _, _<br><br>[request_definition]<br>r = sub, dom, obj, act       <span class="hljs-comment">//sub-用户，dom-域，obj-资源，act-操作</span><br><br>[policy_definition]<br>p = sub, dom, obj, act<br><br>[matchers]<br>m = g(r.sub, p.sub, r.dom) &amp;&amp; r.act == p.act &amp;&amp; r.dom == p.dom &amp;&amp; keyMatch(r.obj, p.obj)<br><br>[policy_effect]<br>e = some(where (p.eft == allow))     <span class="hljs-comment">// 任意一条 policy rule 满足, 则最终结果为 allow</span><br></code></pre></td></tr></table></figure><h3 id="持久化存储权限到mysql并初始化"><a href="#持久化存储权限到mysql并初始化" class="headerlink" title="持久化存储权限到mysql并初始化"></a>持久化存储权限到mysql并初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Casbin</span><span class="hljs-params">()</span> *<span class="hljs-title">casbin</span>.<span class="hljs-title">Enforcer</span></span>&#123;<br>a, _ := gormadapter.NewAdapter(<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;user_name:user_passwd@tcp(127.0.0.1:3306)/&quot;</span>) <span class="hljs-comment">// Your driver and data source.</span><br>e, err := casbin.NewEnforcer(<span class="hljs-string">&quot;./model.conf&quot;</span>, a)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(<span class="hljs-string">&quot;载入casbin配置出错&quot;</span>)<br>&#125;<br><br>e.LoadPolicy() <span class="hljs-comment">// 从数据库载入配置</span><br><span class="hljs-keyword">return</span> e<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitCasbin</span><span class="hljs-params">()</span><span class="hljs-params">(e *casbin.Enforcer ,err error)</span></span> &#123;<br>e = Casbin()<br>gh_dev, gh, data1, read, write, hh_dev, hh_admin, root, gh_admin,hh,data2,zr,gp,lc,mdw,pzc := <span class="hljs-string">&quot;gh_dev&quot;</span>, <span class="hljs-string">&quot;gh&quot;</span>,<span class="hljs-string">&quot;data1&quot;</span>,<span class="hljs-string">&quot;read&quot;</span>,<span class="hljs-string">&quot;write&quot;</span>,<span class="hljs-string">&quot;hh_dev&quot;</span>,<span class="hljs-string">&quot;hh_admin&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;gh_admin&quot;</span>,<span class="hljs-string">&quot;hh&quot;</span>,<span class="hljs-string">&quot;data2&quot;</span>,<span class="hljs-string">&quot;zr&quot;</span>,<span class="hljs-string">&quot;gp&quot;</span>,<span class="hljs-string">&quot;lc&quot;</span>,<span class="hljs-string">&quot;mdw&quot;</span>,<span class="hljs-string">&quot;pzc&quot;</span><br><br>p_pilicies := [][]<span class="hljs-keyword">string</span>&#123;<br>&#123;gh_dev, gh, <span class="hljs-string">&quot;/root*&quot;</span>, get&#125;,<br>&#123;gh_dev, gh, <span class="hljs-string">&quot;/root/age*&quot;</span>, post&#125;,<br>&#123;hh_dev, hh, <span class="hljs-string">&quot;/root*&quot;</span>, get&#125;,<br>&#123;hh_dev, hh, <span class="hljs-string">&quot;/root/age*&quot;</span>, post&#125;,<br>&#123;gh_admin, gh, <span class="hljs-string">&quot;/root*&quot;</span>, post&#125;,<br>&#123;hh_admin, hh, <span class="hljs-string">&quot;/root*&quot;</span>, post&#125;,<br>&#123;root, gh, <span class="hljs-string">&quot;/root*&quot;</span>, get&#125;,<br>&#123;root, gh, <span class="hljs-string">&quot;/root*&quot;</span>, post&#125;,<br>&#123;root, hh, <span class="hljs-string">&quot;/root*&quot;</span>, get&#125;,<br>&#123;root, hh, <span class="hljs-string">&quot;/root*&quot;</span>, post&#125;,<br>&#125;<br>g_pilicies := [][]<span class="hljs-keyword">string</span>&#123;<br>&#123;gh_admin, gh_dev, gh&#125;,<br>&#123;hh_admin, hh_dev, hh&#125;,<br>&#123;zr, gh_dev, gh&#125;,<br>&#123;lc, gh_admin, gh&#125;,<br>&#123;xm, system, gh&#125;,<br>&#123;xm, system, hh&#125;<br>&#125;<br><br>_, err = e.AddPolicies(p_pilicies)                 <br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;添加p失败,错误：%v&quot;</span>,err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>_, err = e.AddGroupingPolicies(g_pilicies)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;添加g失败,错误：%v&quot;</span>,err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> e,<span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编写检查权限函数"><a href="#编写检查权限函数" class="headerlink" title="编写检查权限函数"></a>编写检查权限函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(e *casbin.Enforcer, sub, dom, obj, act <span class="hljs-keyword">string</span>)</span></span> &#123;<br>ok, _ := e.Enforce(sub, dom, obj, act)<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s的%s对%s有%s权限\n&quot;</span>,dom, sub, obj, act)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;权限不足：%s的%s对%s没有%s权限\n&quot;</span>,dom, sub, obj, act)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>e, err := InitCasbin()            <span class="hljs-comment">// 初始化casbin</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;初始化失败，err:%v&quot;</span>,err)<br><span class="hljs-keyword">return</span><br>&#125;<br>url1 := <span class="hljs-string">&quot;/root/&quot;</span><br>url2 := <span class="hljs-string">&quot;/root/age?15&quot;</span><br>url4 := <span class="hljs-string">&quot;/home/name&quot;</span><br><br>check(e, <span class="hljs-string">&quot;zr&quot;</span>, <span class="hljs-string">&quot;gh&quot;</span>, url1, <span class="hljs-string">&quot;get&quot;</span>)<br>check(e, <span class="hljs-string">&quot;zr&quot;</span>, <span class="hljs-string">&quot;gh&quot;</span>, url2, <span class="hljs-string">&quot;post&quot;</span>)<br>check(e, <span class="hljs-string">&quot;zr&quot;</span>, <span class="hljs-string">&quot;gh&quot;</span>, url1, <span class="hljs-string">&quot;post&quot;</span>)         <span class="hljs-comment">// 没有权限</span><br>check(e, <span class="hljs-string">&quot;zr&quot;</span>, <span class="hljs-string">&quot;hh&quot;</span>, url1, <span class="hljs-string">&quot;get&quot;</span>)          <span class="hljs-comment">// 没有权限</span><br>check(e, <span class="hljs-string">&quot;zr&quot;</span>, <span class="hljs-string">&quot;gh&quot;</span>, url4, <span class="hljs-string">&quot;get&quot;</span>)          <span class="hljs-comment">// 没有权限</span><br>check(e, <span class="hljs-string">&quot;zr&quot;</span>, <span class="hljs-string">&quot;gh&quot;</span>, <span class="hljs-string">&quot;/root/name&quot;</span>, <span class="hljs-string">&quot;post&quot;</span>) <span class="hljs-comment">// 没有权限</span><br>check(e, <span class="hljs-string">&quot;lc&quot;</span>, <span class="hljs-string">&quot;gh&quot;</span>, url1, <span class="hljs-string">&quot;get&quot;</span>)<br>check(e, <span class="hljs-string">&quot;lc&quot;</span>, <span class="hljs-string">&quot;gh&quot;</span>, url2, <span class="hljs-string">&quot;post&quot;</span>)<br>check(e, <span class="hljs-string">&quot;lc&quot;</span>, <span class="hljs-string">&quot;gh&quot;</span>, url1, <span class="hljs-string">&quot;post&quot;</span>)<br>check(e, <span class="hljs-string">&quot;lc&quot;</span>, <span class="hljs-string">&quot;gh&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>)  <span class="hljs-comment">// 没有权限</span><br>check(e, <span class="hljs-string">&quot;lc&quot;</span>, <span class="hljs-string">&quot;hh&quot;</span>, url1, <span class="hljs-string">&quot;get&quot;</span>) <span class="hljs-comment">// 没有权限</span><br>e.AddPolicy(<span class="hljs-string">&quot;zr&quot;</span>,<span class="hljs-string">&quot;gh&quot;</span>,<span class="hljs-string">&quot;/root/name*&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>) <span class="hljs-comment">//为zr添加gh的/root/name的get权限</span><br>e.AddGroupingPolicy(<span class="hljs-string">&quot;Jay&quot;</span>,<span class="hljs-string">&quot;gh_admin&quot;</span>,<span class="hljs-string">&quot;gh&quot;</span>)<span class="hljs-comment">// 为Jay添加gh的admin角色</span><br>fmt.Println(<span class="hljs-string">&quot;-------添加权限后-----------&quot;</span>)<br>check(e, <span class="hljs-string">&quot;zr&quot;</span>, <span class="hljs-string">&quot;gh&quot;</span>, <span class="hljs-string">&quot;/root/name?15&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>) <span class="hljs-comment">// 有权限</span><br>check(e, <span class="hljs-string">&quot;Jay&quot;</span>, <span class="hljs-string">&quot;gh&quot;</span>, <span class="hljs-string">&quot;/root&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>) <span class="hljs-comment">// 有权限</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">gh的zr对/root/有get权限<br>gh的zr对/root/age?<span class="hljs-number">15</span>有post权限<br>权限不足：gh的zr对/root/没有post权限<br>权限不足：hh的zr对/root/没有get权限<br>权限不足：gh的zr对/home/name没有get权限<br>权限不足：gh的zr对/root/name没有post权限<br>gh的lc对/root/有get权限<br>gh的lc对/root/age?<span class="hljs-number">15</span>有post权限<br>权限不足：hh的pzc对data2没有write权限<br>hh的system对data2有write权限<br>gh的system对data1有read权限<br>-------添加权限后-----------<br>gh的zr对/root/name?<span class="hljs-number">15</span>有get权限<br>gh的Jay对/root有get权限<br></code></pre></td></tr></table></figure><h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>可以看到上面的<code>root</code>用户是具有最高权限的,可以拥有所有租户的所有数据的所有权限:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">&#123;root, gh, <span class="hljs-string">&quot;/root*&quot;</span>, get&#125;,<br>&#123;root, gh, <span class="hljs-string">&quot;/root*&quot;</span>, post&#125;,<br>&#123;root, hh, <span class="hljs-string">&quot;/root*&quot;</span>, get&#125;,<br>&#123;root, hh, <span class="hljs-string">&quot;/root*&quot;</span>, post&#125;,<br></code></pre></td></tr></table></figure><p>倘若租户数量和租户里的数据较多时，为所有数据一个一个添加权限则会显得相当繁琐，因此必须使用另外的方法来设置<code>root</code>用户的最高权限<br>我们在数据库中建个<code>users</code>表存储用户信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>ID       <span class="hljs-keyword">uint</span><br>UserName <span class="hljs-keyword">string</span> <span class="hljs-string">`gorm:&quot;type:varchar(32);not null;index;&quot;`</span><br>Name     <span class="hljs-keyword">string</span> <span class="hljs-string">`gorm:&quot;type:varchar(32);not null;&quot;`</span><br>Role     <span class="hljs-keyword">string</span> <span class="hljs-string">`gorm:&quot;type:varchar(32);not null;&quot;`</span><br>Domain   <span class="hljs-keyword">string</span> <span class="hljs-string">`gorm:&quot;type:varchar(32);&quot;`</span><br>IsDelete <span class="hljs-keyword">uint8</span>  <span class="hljs-string">`gorm:&quot;default: 0&quot;`</span><br>gorm.Model<br>&#125;<br></code></pre></td></tr></table></figure><p>再编写函数判断当前发起请求用户是否是<code>root</code>用户:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//  判断是否是root用户</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isRoot</span><span class="hljs-params">(sub <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br>userModels, err := GetRootUser()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(fmt.Errorf(<span class="hljs-string">&quot;获取root用户名单失败，原因：%v&quot;</span>, err))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">for</span> _, userModel := <span class="hljs-keyword">range</span> userModels &#123;<br><span class="hljs-keyword">if</span> sub == userModel.UserName &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-comment">//  获取root用户列表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetRootUser</span><span class="hljs-params">()</span></span>&#123;<br>user := []*User&#123;&#125;<br>err := CasbinDb.Where(<span class="hljs-string">&quot;role = ? AND is_delete = ?&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-number">0</span>).Find(&amp;user).Error<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> user, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>用interface类型接口包装上面函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">KeyMatchFunc</span><span class="hljs-params">(arg ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span> &#123;<br>sub := arg[<span class="hljs-number">0</span>].(<span class="hljs-keyword">string</span>)<br><span class="hljs-keyword">return</span> isRoot(sub), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>然后在<code>casbin</code>的<code>enforcer</code>对象中注册这个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">e.AddFunction(<span class="hljs-string">&quot;isRoot&quot;</span>, KeyMatchFunc)<br></code></pre></td></tr></table></figure><p>修改<code>model.conf</code>中的<code>matchers</code>为下面所示(在最后面加上<code>isRoot</code>判断函数)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">[matchers]<br>m = g(r.sub, p.sub, r.dom) &amp;&amp; r.act == p.act &amp;&amp; r.dom == p.dom &amp;&amp; keyMatch(r.obj, p.obj) || isRoot(r.sub)<br></code></pre></td></tr></table></figure><p>现在数据库表中数据为：<img src="https://img-blog.csdnimg.cn/de57797ec31c4f31a400a344433d39fc.png" alt="在这里插入图片描述"></p><p>新增的测试用例为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">url1 := <span class="hljs-string">&quot;/root/&quot;</span><br>check(e, <span class="hljs-string">&quot;root1&quot;</span>, <span class="hljs-string">&quot;hh&quot;</span>, url1, <span class="hljs-string">&quot;get&quot;</span>)<br>check(e, <span class="hljs-string">&quot;root2&quot;</span>, <span class="hljs-string">&quot;dsda&quot;</span>, url1, <span class="hljs-string">&quot;get&quot;</span>)<br>check(e, <span class="hljs-string">&quot;root3&quot;</span>, <span class="hljs-string">&quot;sda&quot;</span>, url1, <span class="hljs-string">&quot;get&quot;</span>) <span class="hljs-comment">// 没有权限,因为数据库中没有root3用户</span><br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hh的root1对/root/有get权限<br>dsda的root2对/root/有get权限<br>权限不足：sda的root3对/root/没有get权限<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go的Goroutine</title>
    <link href="/blog/2021/12/01/Go%E7%9A%84Goroutine/"/>
    <url>/blog/2021/12/01/Go%E7%9A%84Goroutine/</url>
    
    <content type="html"><![CDATA[<h1 id="一、什么是goroutine？"><a href="#一、什么是goroutine？" class="headerlink" title="一、什么是goroutine？"></a>一、什么是goroutine？</h1><p>为了更好理解Goroutine，讲一下相关概念</p><p><strong>线程（Thread）</strong>：有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC），寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。</p><p>线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程的切换一般也由操作系统调度。</p><p><strong>协程（Goroutine）</strong>：是Go里的一种轻量级线程，是一种用户态的线程。相对线程，协程的优势就在于它非常轻量级，进行上下文切换的代价非常的小。对于一个goroutine ,每个结构体G中有一个sched的属性就是用来保存它上下文的。这样，goroutine 就可以很轻易的来回切换。由于其上下文切换在用户态下发生，根本不必进入内核态，所以速度很快。而且只有当前goroutine 的 PC, SP等少量信息需要保存。</p><h1 id="二、使用Goroutine"><a href="#二、使用Goroutine" class="headerlink" title="二、使用Goroutine"></a>二、使用Goroutine</h1><h3 id="1-Goroutine的创建"><a href="#1-Goroutine的创建" class="headerlink" title="1.Goroutine的创建"></a>1.Goroutine的创建</h3><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Hello</span><span class="hljs-params">()</span></span>&#123;<br>fmt.Println(<span class="hljs-string">&quot;Hello World&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">go</span> Hello()  <span class="hljs-comment">//用go关键字便可启动一个协程</span><br><span class="hljs-comment">//也可以使用匿名函数创建goroutine</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(str <span class="hljs-keyword">string</span>)</span></span>&#123;<br>fmt.Println(str)  <span class="hljs-comment">// 结果打印“你好”</span><br>&#125;(<span class="hljs-string">&quot;你好&quot;</span>)<br><span class="hljs-comment">//go中main函数退出的话，其子协程也全部退出。因此这里等待1秒让子协程执行完毕</span><br>time.sleep(<span class="hljs-number">1</span>*time.second)<br><span class="hljs-comment">//但是各groutine之间无父子关系</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-Goroutine的并发与控制"><a href="#2-Goroutine的并发与控制" class="headerlink" title="2.Goroutine的并发与控制"></a>2.Goroutine的并发与控制</h2><h3 id="2-1-runtime-Goexit-强制退出"><a href="#2-1-runtime-Goexit-强制退出" class="headerlink" title="2.1 runtime.Goexit()强制退出"></a>2.1 runtime.Goexit()强制退出</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;A&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;B&quot;</span>)<br>runtime.Goexit()   <span class="hljs-comment">//直接结束该协程，但是defer语句会正常延迟调用</span><br>fmt.Println(<span class="hljs-string">&quot;111&quot;</span>)<br>&#125;()<br>fmt.Println(<span class="hljs-string">&quot;222&quot;</span>)<br>&#125;()<br><br><span class="hljs-keyword">for</span> &#123;    <span class="hljs-comment">// 防止主协程马上退出而使得子协程没有机会运行</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的函数执行结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">A<br>B<br></code></pre></td></tr></table></figure><h3 id="2-2-sync-WaitGroup实现任务同步"><a href="#2-2-sync-WaitGroup实现任务同步" class="headerlink" title="2.2 sync.WaitGroup实现任务同步"></a>2.2 sync.WaitGroup实现任务同步</h3><p>sync.WaitGroup维护了一个计数器，计数器的值可以增加和减少，比如我们可以启动了N个goroutine后对计数器加N，每完成一个并发任务，调用Done()对计数器减一，当计数器为0时表示所有并发任务完成。</p><table><thead><tr><th align="center">方法名</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">Add(delta)</td><td align="center">计数器加delta</td></tr><tr><td align="center">Done()</td><td align="center">计数器减1</td></tr><tr><td align="center">Wait()</td><td align="center">阻塞直到计数器变为0</td></tr></tbody></table><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">print</span><span class="hljs-params">(wg *sync.WaitGroup)</span></span>&#123;<br>fmt.Println(<span class="hljs-string">&quot;你好&quot;</span>)<br>wg.Done()  <span class="hljs-comment">// 任务完成，计数器减1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>wg.Add(<span class="hljs-number">2</span>)      <span class="hljs-comment">// 为计数器增加2</span><br><br><span class="hljs-keyword">go</span> <span class="hljs-built_in">print</span>(&amp;wg)   <span class="hljs-comment">// 开启两个goroutine执行任务</span><br><span class="hljs-keyword">go</span> <span class="hljs-built_in">print</span>(&amp;wg)<br><br>wg.Wait()    <span class="hljs-comment">// 阻塞等待任务完成</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-通过context上下文"><a href="#2-3-通过context上下文" class="headerlink" title="2.3 通过context上下文"></a>2.3 通过context上下文</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// WithCancel()函数接受一个 Context 并返回其子Context和取消函数cancel</span><br>ctx, cancel := context.WithCancel(context.Background())<span class="hljs-comment">//context.Background()返回空context</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c context.Context)</span></span> &#123;<br>i := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;打印%d次\n&quot;</span>,i)<br>i++<br>time.Sleep(<span class="hljs-number">1</span>*time.Second)<br>&#125;<br>&#125;(ctx)<br>time.Sleep(<span class="hljs-number">3</span>*time.Second)<br>cancel()           <span class="hljs-comment">// 调用cancel方法向父context的context.Done发送信息，使得父子协程关闭</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-通过channel通信"><a href="#2-4-通过channel通信" class="headerlink" title="2.4 通过channel通信"></a>2.4 通过channel通信</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>stop := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">1</span>)<br>i := <span class="hljs-number">1</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(stop &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span>&#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;- stop:<br>fmt.Println(<span class="hljs-string">&quot;子协程退出&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Printf(<span class="hljs-string">&quot;打印：%d次\n&quot;</span>, i)<br>i++<br>time.Sleep(<span class="hljs-number">1</span>*time.Second)<br>&#125;<br>&#125;<br>&#125;(stop)<br>time.Sleep(<span class="hljs-number">3</span>*time.Second)<br>stop &lt;- <span class="hljs-number">1</span><br>time.Sleep(<span class="hljs-number">1</span>*time.Second)<br>fmt.Println(<span class="hljs-string">&quot;主协程结束&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-runtime-Gosched-切换时间片"><a href="#2-5-runtime-Gosched-切换时间片" class="headerlink" title="2.5 runtime.Gosched()切换时间片"></a>2.5 runtime.Gosched()切换时间片</h3><p>Gosched()函数的作用是为当前的goroutine切换时间片，让出时间给其他goroutine执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++&#123;<br>fmt.Println(<span class="hljs-string">&quot;这是goroutine&quot;</span>)<br>&#125;<br>&#125;()<br><br>fmt.Println(<span class="hljs-string">&quot;这是main&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码中，因为主协程其实是要比子协程更快运行的，并且主协程退出后，其子协程也相应退出因此子协程没有运行机会，所以输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">这是main<br></code></pre></td></tr></table></figure><p>这次我们为主协程加上runtime.Gosched()函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++&#123;<br>fmt.Println(<span class="hljs-string">&quot;这是goroutine&quot;</span>)<br>&#125;<br>&#125;()<br>runtime.Gosched() <span class="hljs-comment">// 将主协程的时间片让出，使得上面的子协程有机会运行</span><br>fmt.Println(<span class="hljs-string">&quot;这是main&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">这是goroutine<br>这是goroutine<br>这是goroutine<br>这是main<br></code></pre></td></tr></table></figure><h3 id="2-6-定时器和打点器"><a href="#2-6-定时器和打点器" class="headerlink" title="2.6 定时器和打点器"></a>2.6 定时器和打点器</h3><p>定时器(Timer)的作用就是设置未来的某个时间执行某个任务，如现在是10:30,设置个1小时的定时器，11:30开始执行吃饭任务<br>打点器(Ticker)的作用是隔相同时间执行一段任务，如每隔30分钟喝一杯水<br>代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span><br>timer := time.NewTimer(time.Second)      <span class="hljs-comment">// 设置1秒的定时器</span><br>ticker := time.NewTicker(<span class="hljs-number">2</span>*time.Second)  <span class="hljs-comment">// 设置2秒的打点器duration</span><br><br>fmt.Printf(<span class="hljs-string">&quot;定时器开始时间：%v\n&quot;</span>, time.Now())<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> t :=&lt;- timer.C:     <span class="hljs-comment">// 1秒后系统会向timer.C中发送数据</span><br>fmt.Printf(<span class="hljs-string">&quot;定时器结束时间：%v\n&quot;</span>,t)<br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;打点器开始运行：%v\n&quot;</span>,time.Now())<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// 单独起个goroutine执行打点器程序</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> t1 := &lt;- ticker.C:<br>i++<br>fmt.Printf(<span class="hljs-string">&quot;打点器打点%d：%v\n&quot;</span>,i ,t1)<br>&#125;<br>&#125;<br>&#125;()<br><br>time.Sleep(<span class="hljs-number">6</span>*time.Second)    <span class="hljs-comment">//让主协程睡眠6秒后退出，使得打点器的子协程有时间运行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">定时器开始时间：<span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-01</span> <span class="hljs-number">11</span>:<span class="hljs-number">10</span>:<span class="hljs-number">50.3962379</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">0.000062001</span><br>定时器结束时间：<span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-01</span> <span class="hljs-number">11</span>:<span class="hljs-number">10</span>:<span class="hljs-number">51.3963637</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">1.000187801</span><br>打点器开始运行：<span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-01</span> <span class="hljs-number">11</span>:<span class="hljs-number">10</span>:<span class="hljs-number">51.3964422</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">1.000266301</span><br>打点器打点<span class="hljs-number">1</span>：<span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-01</span> <span class="hljs-number">11</span>:<span class="hljs-number">10</span>:<span class="hljs-number">52.3965124</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">2.000336601</span><br>打点器打点<span class="hljs-number">2</span>：<span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-01</span> <span class="hljs-number">11</span>:<span class="hljs-number">10</span>:<span class="hljs-number">54.3973869</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">4.001211001</span><br>打点器打点<span class="hljs-number">3</span>：<span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-01</span> <span class="hljs-number">11</span>:<span class="hljs-number">10</span>:<span class="hljs-number">56.3974749</span> +<span class="hljs-number">0800</span> CST m=+<span class="hljs-number">6.001299001</span><br></code></pre></td></tr></table></figure><h3 id="2-7-并发安全和锁"><a href="#2-7-并发安全和锁" class="headerlink" title="2.7 并发安全和锁"></a>2.7 并发安全和锁</h3><p>由于go中各gooutine是并发执行的，因此倘若有多个goroutine对同一变量进行更改便会很容易出现数据竟态问题<br>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeMap</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>)</span></span>&#123;    <span class="hljs-comment">// 对map进行写入</span><br><span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10000</span>;i++&#123;<br>m[<span class="hljs-number">1</span>] = i<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m1 := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>: <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-keyword">go</span> writeMap(m1)      <span class="hljs-comment">// 起两个goroutine对同一个map进行写入操作</span><br><span class="hljs-keyword">go</span> writeMap(m1)<br><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fatal error: concurrent <span class="hljs-keyword">map</span> writes<br></code></pre></td></tr></table></figure><p>解决问题便是对写入操作进行加锁，go中的的sync包提供对锁的支持，其中有Mutex互斥锁和RWMutex读写互斥锁，其中Mutex锁是完全互斥的，而RWMutex可以对读操作兼容，因此读多写少的情况更适用于RWMutex锁。</p><p><strong>对上面代码进行加锁</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeMap</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>, mu *sync.Mutex)</span></span>&#123;<br><span class="hljs-keyword">for</span> i:= <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10000</span>;i++&#123;<br>mu.Lock()<br>m[<span class="hljs-number">1</span>] = i<br>mu.Unlock()<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m1 := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>: <span class="hljs-number">1</span>&#125;<br>mutex := sync.Mutex&#123;&#125;<br><br><span class="hljs-keyword">go</span> writeMap(m1,&amp;mutex)<br><span class="hljs-keyword">go</span> writeMap(m1,&amp;mutex)<br><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-8-sync-Map"><a href="#2-8-sync-Map" class="headerlink" title="2.8 sync.Map"></a>2.8 sync.Map</h3><p>其实go的sync包提供了并发安全版的map：sync.Map,其提供了诸如Store、Load、LoadOrStore、Delete、Range等操作方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeMap</span><span class="hljs-params">(m *sync.Map)</span></span>&#123;<br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10000</span>;i++&#123;<br>m.Store(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">18</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := sync.Map&#123;&#125;<br><br><span class="hljs-keyword">go</span> writeMap(&amp;m)     <span class="hljs-comment">// 同时开启两个goroutine对map不停写入</span><br><span class="hljs-keyword">go</span> writeMap(&amp;m)<br>time.Sleep(time.Second)  <span class="hljs-comment">// 确保上面两个协程任务完成</span><br><br>v, _ := m.Load(<span class="hljs-string">&quot;age&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;年龄是：%v\n&quot;</span>,v)<br>m.Delete(<span class="hljs-string">&quot;age&quot;</span>)<br>v, exist := m.Load(<span class="hljs-string">&quot;age&quot;</span>)<br><span class="hljs-keyword">if</span> !exist &#123;<br>fmt.Println(<span class="hljs-string">&quot;age不存在&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">年龄是：<span class="hljs-number">18</span><br>age不存在<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go的Channel总结</title>
    <link href="/blog/2021/11/30/Go%E7%9A%84Channel%E6%80%BB%E7%BB%93/"/>
    <url>/blog/2021/11/30/Go%E7%9A%84Channel%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><font color=#999AAA >学习Go语言已有4个月，在此对Go语言相关知识点做个总结</p></font><p>@<a href="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">TOC</a></p><hr style=" border:solid; width:100%; height:1px;" color=#000000 size=1"><h1 id="一-Go中的Channel是什么？"><a href="#一-Go中的Channel是什么？" class="headerlink" title="一. Go中的Channel是什么？"></a>一. Go中的Channel是什么？</h1><p>Go语言的并发模型是<code>CSP(Communicating Sequential Processes)</code>，提倡通过通信共享内存而不是通过共享内存而实现通信。<br><code>Channel</code>是一种特殊的类型。通道像一个传送带或者队列，总是遵循先入先出<code>(First In First Out)</code>的规则，保证收发数据的顺序，可以类比成<code>Unix</code> 中的进程的通信方式管道。<br>使用<code>channel</code>可以方便地在各<code>goroutine</code>之间传递数据，保证了各协程的通信。</p><h1 id="二-Channel语法"><a href="#二-Channel语法" class="headerlink" title="二. Channel语法"></a>二. Channel语法</h1><h2 id="1-定义和创建Channel"><a href="#1-定义和创建Channel" class="headerlink" title="1.定义和创建Channel"></a>1.定义和创建Channel</h2><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span> <span class="hljs-comment">//定义一个int类型的channel</span><br><span class="hljs-keyword">var</span> ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">//创建一个传递string类型的channel，缓冲为5</span><br></code></pre></td></tr></table></figure><h2 id="2-操作Channel"><a href="#2-操作Channel" class="headerlink" title="2.操作Channel"></a>2.操作Channel</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">//先定义一个传递int类型的缓冲为5的channel</span><br>ch &lt;- <span class="hljs-number">8</span>  <span class="hljs-comment">//将8发送到ch中</span><br>a := &lt;- ch  <span class="hljs-comment">//用变量a来接收</span><br>&lt;- ch  <span class="hljs-comment">//从ch中接受，忽略结果</span><br><span class="hljs-built_in">close</span>(ch)  <span class="hljs-comment">// 关闭channel</span><br></code></pre></td></tr></table></figure><p><strong>对于关闭channel需要注意：</strong></p><ul><li>对关闭后的<code>channel</code>进行发送数据操作会导致<code>panic</code></li><li>对关闭后的<code>channel</code>进行读数据操作会一直接收值，直到<code>channel</code>中无数据</li><li>对一个已关闭的无数据的<code>channel</code>进行读操作会接收到对应类型的0值，如int类型接收到<code>0</code>，<code>string</code>类型接收到<code>&quot;&quot;</code></li><li>关闭一个已经关闭的<code>channel</code>会导致<code>panic</code></li></ul><h2 id="3-Channel的缓冲"><a href="#3-Channel的缓冲" class="headerlink" title="3.Channel的缓冲"></a>3.Channel的缓冲</h2><p>Channel分为有缓冲和无缓冲两种</p><ul><li><p>无缓冲：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>ch &lt;- <span class="hljs-number">8</span><br>fmt.Println(<span class="hljs-string">&quot;发送数据成功&quot;</span>)<br></code></pre></td></tr></table></figure><p>上面代码执行结果会报错，不会打印<code>&quot;发送数据成功&quot;</code>，因为ch通道没有缓冲，对其发送数据后，协程便会一直阻塞在此，除非另一个协程对ch进行读取操作，才会继续执行后面的代码</p></li><li><p>有缓冲</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment">// ch缓冲为2</span><br></code></pre></td></tr></table></figure></li></ul><p>一般使用<code>for range</code>结构对<code>channel</code>进行读取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 定义一个缓冲为3的channel</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++ &#123;<br>ch &lt;- i <span class="hljs-comment">//向ch中连续发送3个数据</span><br>&#125;<br><span class="hljs-built_in">close</span>(ch)  <span class="hljs-comment">// 别忘了关闭channel</span><br><span class="hljs-comment">// 使用for range读取channel，当channel中数据被读完后，会自动退出for循环</span><br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;<br>fmt.Println(v)  <span class="hljs-comment">// 打印结果分别为 0  1  2</span><br>&#125;<br><br><span class="hljs-comment">// 再对已关闭的ch进行直接读取</span><br>fmt.Println(&lt;- ch) <span class="hljs-comment">// 打印结果为 0，即int类型对应的零值</span><br><span class="hljs-comment">//再次对ch进行读取</span><br>a, ok := &lt;- ch<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Println(a)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;接收失败，channel已经关闭&quot;</span>)  <span class="hljs-comment">// 会打印该条语句，因为ch已经关闭</span><br>&#125;<br><br><span class="hljs-comment">//此时再对ch发送数据</span><br>ch &lt;- <span class="hljs-number">8</span> <span class="hljs-comment">// 会报错：panic: send on closed channel</span><br></code></pre></td></tr></table></figure><h2 id="4-单向Channel和双向Channel"><a href="#4-单向Channel和双向Channel" class="headerlink" title="4. 单向Channel和双向Channel"></a>4. 单向Channel和双向Channel</h2><p>其实<code>channel</code>都是双向的，单向<code>channel</code>主要用于方法声明，防止<code>channel</code>被滥用。<br>一个<code>单独存在</code>的<code>单向channel</code>是<code>毫无意义</code>的。<br>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">example</span><span class="hljs-params">(ch &lt;- <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span>&#123;  <span class="hljs-comment">//传入channel，channel在该函数中只能向外发送数据</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span>&#123;<br><span class="hljs-keyword">case</span> &lt;- ch:<br>fmt.Println(<span class="hljs-string">&quot;你好&quot;</span>)<br>&#125;<br>&#125;<br><br>ch &lt;- <span class="hljs-number">1</span>  <span class="hljs-comment">// 会报错</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment">//定义一个双向channel</span><br>example(ch)<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="三-使用场景"><a href="#三-使用场景" class="headerlink" title="三. 使用场景"></a>三. 使用场景</h1><h3 id="1-用于goroutine之间的消息传递"><a href="#1-用于goroutine之间的消息传递" class="headerlink" title="1. 用于goroutine之间的消息传递:"></a>1. 用于goroutine之间的消息传递:</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">work</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span>&#123;<br>fmt.Println(<span class="hljs-string">&quot;任务执行中......&quot;</span>)<br>time.Sleep(<span class="hljs-number">1</span>*time.Second)<br>ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;               <span class="hljs-comment">// 传递消息给通道</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">go</span> work(ch)<br>&lt;- ch                         <span class="hljs-comment">// 阻塞等待消息</span><br>fmt.Println(<span class="hljs-string">&quot;任务完成!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">任务执行中......<br>任务完成!<br><br>进程 已完成，退出代码为 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="2-用于goroutine之间数据传递"><a href="#2-用于goroutine之间数据传递" class="headerlink" title="2. 用于goroutine之间数据传递"></a>2. 用于goroutine之间数据传递</h3><p>如交替打印数字和字母：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">num</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int32</span>)</span></span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int32</span><br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-number">27</span> &#123;<br>i = &lt;- ch<br>fmt.Printf(<span class="hljs-string">&quot;%d%d&quot;</span>,i,i+<span class="hljs-number">1</span>)<br>i = i+<span class="hljs-number">2</span><br>ch &lt;- i<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">char</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int32</span>,wg *sync.WaitGroup)</span></span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int32</span><br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-number">29</span> &#123;<br>i = &lt;- ch<br>fmt.Printf(<span class="hljs-string">&quot;%s%s&quot;</span>,<span class="hljs-keyword">string</span>(i+<span class="hljs-number">62</span>),<span class="hljs-keyword">string</span>(i+<span class="hljs-number">63</span>))<br>wg.Done()<br>ch &lt;- i<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg := sync.WaitGroup&#123;&#125;      <br>wg.Add(<span class="hljs-number">13</span>)<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int32</span>)<br><span class="hljs-keyword">go</span> num(ch)            <span class="hljs-comment">// 开启打印数字协程</span><br>ch &lt;- <span class="hljs-number">1</span><br><span class="hljs-keyword">go</span> char(ch,&amp;wg)       <span class="hljs-comment">//开启打印字母协程</span><br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-控制并发数量"><a href="#3-控制并发数量" class="headerlink" title="3. 控制并发数量"></a>3. 控制并发数量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>jobCount := <span class="hljs-number">38</span><br>wg := sync.WaitGroup&#123;&#125;<br>wg.Add(jobCount)<br>limit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;,<span class="hljs-number">10</span>)       <span class="hljs-comment">// 并发数量限制为10</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; jobCount; i++ &#123;<br>limit &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;任务执行中&quot;</span>)<br>time.Sleep(<span class="hljs-number">1</span>*time.Second)<br>&lt;- limit<br>wg.Done()<br>&#125;()<br>&#125;<br>wg.Wait()<br>fmt.Println(<span class="hljs-string">&quot;任务完成&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-超时控制"><a href="#4-超时控制" class="headerlink" title="4. 超时控制"></a>4. 超时控制</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">work</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">struct</span></span>&#123;&#125; &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;开始任务&quot;</span>)<br>time.Sleep(<span class="hljs-number">3</span> * time.Second)<br>ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;()<br><span class="hljs-keyword">return</span> ch<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-work(ch):<br>fmt.Println(<span class="hljs-string">&quot;任务准时完成&quot;</span>)<br><span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">1</span> * time.Second):<br>fmt.Println(<span class="hljs-string">&quot;任务超时&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四-Channel注意事项"><a href="#四-Channel注意事项" class="headerlink" title="四. Channel注意事项"></a>四. Channel注意事项</h1><h2 id="1-len和cap的区别"><a href="#1-len和cap的区别" class="headerlink" title="1.len和cap的区别"></a>1.len和cap的区别</h2><ul><li><code>len</code>指<code>channel</code>中已有的数据长度,<code>cap</code>指<code>channel</code>定义时的容量，即缓冲<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>)<br>ch &lt;- <span class="hljs-number">9</span><br>ch &lt;- <span class="hljs-number">6</span><br>fmt.Println(<span class="hljs-built_in">len</span>(ch1))  <span class="hljs-comment">// 输出 2</span><br>fmt.Println(<span class="hljs-built_in">cap</span>(ch1))  <span class="hljs-comment">// 输出 3</span><br>ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>fmt.Println(<span class="hljs-built_in">cap</span>(ch2))  <span class="hljs-comment">// 输出 0</span><br></code></pre></td></tr></table></figure><h2 id="2-可能存在的危险"><a href="#2-可能存在的危险" class="headerlink" title="2.可能存在的危险"></a>2.可能存在的危险</h2><h3 id="1-使用channel不当造成阻塞"><a href="#1-使用channel不当造成阻塞" class="headerlink" title="1.使用channel不当造成阻塞"></a>1.使用channel不当造成阻塞</h3>示例一：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>ch &lt;- <span class="hljs-number">1</span><br>fmt.Println(&lt;- ch)<br>&#125;<br></code></pre></td></tr></table></figure>运行报错<code>fatal error: all goroutines are asleep - deadlock!</code><br>因为ch是无缓冲channel，当c接收了值后，必须要有另一个goroutine对ch进行读取，程序才能进行下去，否则阻塞。</li></ul><p>示例二：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">1</span>)<br>ch &lt;- <span class="hljs-number">1</span><br>ch &lt;- <span class="hljs-number">2</span><br>fmt.Println(&lt;- ch)<br>&#125;<br></code></pre></td></tr></table></figure><p>该情况也会运行报错，因为原因同上</p><h3 id="2-channel未关闭"><a href="#2-channel未关闭" class="headerlink" title="2. channel未关闭"></a>2. channel未关闭</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>,<span class="hljs-number">2</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span>&#123;<br>ch &lt;- <span class="hljs-number">1</span><br>ch &lt;- <span class="hljs-number">3</span><br>&#125;(ch)<br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> ch &#123;<br>fmt.Println(v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>报错<code>fatal error: all goroutines are asleep - deadlock!</code><br>channel未关闭导致的错误，应该在向channel发送数据完成后对其用<code>close()</code>函数进行关闭</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go的轻量权限控制库-Casbin的使用</title>
    <link href="/blog/2021/11/29/Go%E7%9A%84%E8%BD%BB%E9%87%8F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E5%BA%93-Casbin%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/blog/2021/11/29/Go%E7%9A%84%E8%BD%BB%E9%87%8F%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E5%BA%93-Casbin%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://casbin.org/docs/zh-CN/get-started">casbin官网</a><br>实习的时候项目要求使用casbin来进行权限控制，因此简单记录下casbin的练手</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>截至<code>2021.11.29</code>日，<code>casbin</code>的最新版本为<code>v2</code></p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">go get github.com/casbin/casbin/v2<br></code></pre></td></tr></table></figure><h3 id="编写模型文件model-conf"><a href="#编写模型文件model-conf" class="headerlink" title="编写模型文件model.conf"></a>编写模型文件<code>model.conf</code></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">[role_definition]<br>g = _, _<br><br>[request_definition]<br>r = sub, obj, act<br><br>[policy_definition]<br>p = sub, obj, act<br><br>[policy_effect]<br>e = some(where (p.eft == allow))<br><br>[matchers]<br>m = g(r.sub , p.sub) &amp;&amp; r.obj == p.obj &amp;&amp; r.act == p.act     <span class="hljs-comment">//r.sub必须属于p.sub,后面同理</span><br></code></pre></td></tr></table></figure><h3 id="编写策略文件policy-csv"><a href="#编写策略文件policy-csv" class="headerlink" title="编写策略文件policy.csv"></a>编写策略文件policy.csv</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">p, ops, <span class="hljs-string">&quot;/api/v1/cmdb/environment&quot;</span>, <span class="hljs-string">&quot;GET&quot;</span>  <span class="hljs-comment">//表示ops角色只能用GET方法访问该URL</span><br>g, zr, dev                                  <span class="hljs-comment">// 表示用户zr属于dev角色</span><br>g, lc, ops<br>g, ops, dev<span class="hljs-comment">// 表示角色ops也属于dev角色中的一种，类似于鸡属于鸟，麻雀也属于鸟</span><br>g, system, ops<br></code></pre></td></tr></table></figure><h3 id="编写gin的中间件代码"><a href="#编写gin的中间件代码" class="headerlink" title="编写gin的中间件代码"></a>编写gin的中间件代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Casbin</span><span class="hljs-params">()</span> *<span class="hljs-title">casbin</span>.<span class="hljs-title">Enforcer</span></span> &#123;<br><span class="hljs-comment">//两个文件的路径均为相对于main.go的位置</span><br>e, err := casbin.NewEnforcer(<span class="hljs-string">&quot;conf/casbin_model.conf&quot;</span>, <span class="hljs-string">&quot;conf/casbin_policy.csv&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Errorf(<span class="hljs-string">&quot;载入casbin出错:&quot;</span>,err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>err = e.LoadPolicy()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Errorf(<span class="hljs-string">&quot;载入权限管理出错:&quot;</span>,err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> e<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Ops</span><span class="hljs-params">()</span> <span class="hljs-title">gin</span>.<span class="hljs-title">HandlerFunc</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *gin.Context)</span></span> &#123;<br>u, exists := c.Get(<span class="hljs-string">&quot;userInfo&quot;</span>)<br><span class="hljs-keyword">if</span> !exists &#123;<br>log.Errorf(<span class="hljs-string">&quot;获取用户失败&quot;</span>)<br>c.JSON(<span class="hljs-number">200</span>,payload.FailurePayload(constant.COOKIE_ERROR, constant.COOKIE_ERROR_MSG))<br>c.Abort()<br>&#125;<br>user := u.(sys.User)<br><br>e := Casbin()<br>ok, err := e.Enforce(user.Role, c.Request.URL.Path, c.Request.Method)<br><span class="hljs-keyword">if</span> ok &#123;<br>log.Infof(<span class="hljs-string">&quot;角色为：%s,权限通过&quot;</span>,userModel.Role)<br>c.Next()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log.Errorf(<span class="hljs-string">&quot;角色为：%s,权限不足&quot;</span>,userModel.Role)<br>c.Abort()<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS7安装图形化界面xfce4</title>
    <link href="/blog/2021/09/30/CentOS7%E5%AE%89%E8%A3%85%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2xfce4/"/>
    <url>/blog/2021/09/30/CentOS7%E5%AE%89%E8%A3%85%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2xfce4/</url>
    
    <content type="html"><![CDATA[<p>WSL2中的CentOS7没有图形化界面，很多人用不习惯，于是我们可以为CentOS7安装图形化界面。<br><strong>如果想在WSL2中装CentOS系统可看我的这篇文章<a href="http://118.178.237.76/2021/09/20/WSL%E5%AE%89%E8%A3%85CentOS7/">WSL安装CentOS7</a></strong></p><h3 id="更新yum源"><a href="#更新yum源" class="headerlink" title="更新yum源"></a>更新yum源</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">yum update<br>yum install epel-release <br></code></pre></td></tr></table></figure><h3 id="安装X-WINDOWS"><a href="#安装X-WINDOWS" class="headerlink" title="安装X WINDOWS"></a>安装X WINDOWS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum groupinstall <span class="hljs-string">&quot;X Window System&quot;</span> <br></code></pre></td></tr></table></figure><p> 当出现 Complete！说明这里安装成功了。</p><h3 id="安装xfce"><a href="#安装xfce" class="headerlink" title="安装xfce"></a>安装xfce</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum groupinstall xfce <br></code></pre></td></tr></table></figure><p>执行<code>sudo systemctl isolate graphical.target</code>进入系统，但是不知道为什么，我这里无效</p><h3 id="打开XLaunch"><a href="#打开XLaunch" class="headerlink" title="打开XLaunch"></a>打开XLaunch</h3><p><img src="https://img-blog.csdnimg.cn/10ae47f7a5224c918054e71a0894fabc.png" alt="XLaunch"><br>注意第三步，这里要打勾</p><p><img src="https://img-blog.csdnimg.cn/c8e06659c995481eada8e17820612a7d.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5p6r6Iqx5rW3,size_20,color_FFFFFF,t_70,g_se,x_16"><br>启动后啥也没有是正常的</p><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p><code>xprofile</code>和<code>profile</code>文件中写入配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/profile  <span class="hljs-comment">##编辑/etc/profile文件</span><br><span class="hljs-comment">##添加如下内容</span><br><span class="hljs-built_in">alias</span> xfce4=<span class="hljs-string">&quot;. /etc/xprofile &amp;&amp; startxfce4&quot;</span><br><span class="hljs-built_in">export</span> DISPLAY=$(cat /etc/resolv.conf | grep nameserver | awk <span class="hljs-string">&#x27;&#123;print $2; exit;&#125;&#x27;</span>):0.0<br><span class="hljs-comment">#######################分割线##########################</span><br><br>vi /etc/xprofile  <span class="hljs-comment">##编辑/etc/xprofile文件</span><br><span class="hljs-comment">##添加如下内容</span><br><span class="hljs-built_in">export</span> LANG=zh_CN.UTF-8<br><span class="hljs-built_in">export</span> LANGUAGE=zh_CN:en_US<br><span class="hljs-built_in">export</span> LC_CTYPE=en_US.UTF-8<br><span class="hljs-built_in">export</span> GTK_IM_MODULE=fcitx<br><span class="hljs-built_in">export</span> QT_IM_MODULE=fcitx<br><span class="hljs-built_in">export</span> XMODIFIERS=<span class="hljs-string">&quot;@im=fcitx&quot;</span><br></code></pre></td></tr></table></figure><p>此时重启系统，然后在终端输入<code>xfce4</code>就可启动桌面了</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>CentOS7</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10分钟看懂Docker和K8S</title>
    <link href="/blog/2021/09/26/10%E5%88%86%E9%92%9F%E7%9C%8B%E6%87%82Docker%E5%92%8CK8S/"/>
    <url>/blog/2021/09/26/10%E5%88%86%E9%92%9F%E7%9C%8B%E6%87%82Docker%E5%92%8CK8S/</url>
    
    <content type="html"><![CDATA[<blockquote><p>昨天看到一个讲K8S和docker的文章，觉得挺不错的，分享一下<br> 原文链接: <a href="https://zhuanlan.zhihu.com/p/53260098">10分钟看懂Docker和K8S</a></p></blockquote><p>2010年，几个搞IT的年轻人，在美国旧金山成立了一家名叫“dotCloud”的公司。<br><img src="https://pic4.zhimg.com/80/v2-e6390d9358b05d82105fe391762346b3_720w.jpg"></p><p>这家公司主要提供基于PaaS的云计算技术服务。具体来说，是和LXC有关的容器技术。<br><img src="https://pic3.zhimg.com/80/v2-63e6181057a7837a6150ac084a8e41b6_720w.jpg" alt="LXC，就是Linux容器虚拟技术（Linux container）"></p><p>LXC，就是Linux容器虚拟技术（Linux container）</p><p>后来，dotCloud公司将自己的容器技术进行了简化和标准化，并命名为——Docker。</p><p><img src="https://pic4.zhimg.com/80/v2-2ac9ff25114ecd2fedb0baec3b5f8bcf_720w.jpg"></p><p>Docker技术诞生之后，并没有引起行业的关注。而dotCloud公司，作为一家小型创业企业，在激烈的竞争之下，也步履维艰。</p><p>正当他们快要坚持不下去的时候，脑子里蹦出了“开源”的想法。</p><p>什么是“开源”？开源，就是开放源代码。也就是将原来内部保密的程序源代码开放给所有人，然后让大家一起参与进来，贡献代码和意见。<br><img src="https://pic1.zhimg.com/80/v2-0d5656bdb4300b59820ac0de839d9b50_720w.jpg" alt="Open Source，开源"></p><p>有的软件是一开始就开源的。也有的软件，是混不下去，创造者又不想放弃，所以选择开源。自己养不活，就吃“百家饭”嘛。</p><p>2013年3月，dotCloud公司的创始人之一，Docker之父，28岁的Solomon Hykes正式决定，将Docker项目开源。<br><img src="https://pic4.zhimg.com/80/v2-74a674a7aca771d4d5ea8be1ef380da7_720w.jpg" alt="Solomon Hykes(今年刚从Docker离职)"><br>不开则已，一开惊人。越来越多的IT工程师发现了Docker的优点，然后蜂拥而至，加入Docker开源社区。Docker的人气迅速攀升，速度之快，令人瞠目结舌。</p><p>开源当月，Docker 0.1版本发布。此后的每一个月，Docker都会发布一个版本。到2014年6月9日，Docker 1.0版本正式发布。</p><p>此时的Docker，已经成为行业里人气最火爆的开源技术，没有之一。甚至像Google、微软、Amazon、VMware这样的巨头，都对它青睐有加，表示将全力支持。</p><p>Docker火了之后，dotCloud公司干脆把公司名字也改成了Docker Inc.。Docker和容器技术为什么会这么火爆？说白了，就是因为它“轻”。</p><p>在容器技术之前，业界的网红是虚拟机。虚拟机技术的代表，是VMWare和OpenStack。<br><img src="https://pic2.zhimg.com/80/v2-a77dceb6ebc290b6476e50b88c431985_720w.jpg"></p><p>相信很多人都用过虚拟机。虚拟机，就是在你的操作系统里面，装一个软件，然后通过这个软件，再模拟一台甚至多台“子电脑”出来。<br><img src="https://pic3.zhimg.com/80/v2-31a159040af2711fb14f81a9cb9b5b06_720w.jpg" alt="虚拟机，类似于“子电脑”"></p><p>虚拟机，类似于“子电脑”。在“子电脑”里，你可以和正常电脑一样运行程序，例如开QQ。如果你愿意，你可以变出好几个“子电脑”，里面都开上QQ。“子电脑”和“子电脑”之间，是相互隔离的，互不影响。</p><p>虚拟机属于虚拟化技术。而Docker这样的容器技术，也是虚拟化技术，属于轻量级的虚拟化。</p><p>虚拟机虽然可以隔离出很多“子电脑”，但占用空间更大，启动更慢，虚拟机软件可能还要花钱（例如VMWare）。</p><p>而容器技术恰好没有这些缺点。它不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境（类似“沙箱”）。<br><img src="https://pic2.zhimg.com/80/v2-6328f613b98c1efaf8d47ff9f134c4d9_720w.jpg"><br>它启动时间很快，几秒钟就能完成。而且，它对资源的利用率很高（一台主机可以同时运行几千个Docker容器）。此外，它占的空间很小，虚拟机一般要几GB到几十GB的空间，而容器只需要MB级甚至KB级。<br><img src="https://pic3.zhimg.com/80/v2-c2a31e2008835b2974170ad1dbac0d42_720w.jpg" alt="容器和虚拟机的对比"></p><p>正因为如此，容器技术受到了热烈的欢迎和追捧，发展迅速。我们具体来看看Docker。</p><p>大家需要注意，Docker本身并不是容器，它是创建容器的工具，是应用容器引擎。</p><p>想要搞懂Docker，其实看它的两句口号就行。</p><p>第一句，是“Build, Ship and Run”。<br><img src="https://pic2.zhimg.com/80/v2-d733699d51c1c95f89ac7864f6ac7c31_720w.jpg"></p><p>也就是，“搭建、发送、运行”，三板斧。</p><p>举个例子：</p><p>我来到一片空地，想建个房子，于是我搬石头、砍木头、画图纸，一顿操作，终于把这个房子盖好了。<br><img src="https://pic4.zhimg.com/80/v2-3510cae800d084679a5482ae4c0dbf4f_720w.jpg"></p><p>结果，我住了一段时间，想搬到另一片空地去。这时候，按以往的办法，我只能再次搬石头、砍木头、画图纸、盖房子。</p><p>但是，跑来一个老巫婆，教会我一种魔法。</p><p>这种魔法，可以把我盖好的房子复制一份，做成“镜像”，放在我的背包里。<br><img src="https://pic1.zhimg.com/80/v2-41444ed46f673687eed7c94f81c373b8_720w.jpg"></p><p>等我到了另一片空地，就用这个“镜像”，复制一套房子，摆在那边，拎包入住。<br><img src="https://pic1.zhimg.com/80/v2-c41526641da06bfb97dd2ac1f57aa9c4_720w.jpg"></p><p>怎么样？是不是很神奇？</p><p>所以，Docker的第二句口号就是：“Build once，Run anywhere（搭建一次，到处能用）”。</p><p>Docker技术的三大核心概念，分别是：</p><ul><li>镜像（Image）</li><li>容器（Container）</li><li>仓库（Repository）<br>我刚才例子里面，那个放在包里的“镜像”，就是Docker镜像。而我的背包，就是Docker仓库。我在空地上，用魔法造好的房子，就是一个Docker容器。</li></ul><p>说白了，这个Docker镜像，是一个特殊的文件系统。它除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（例如环境变量）。</p><p>镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p><p>也就是说，每次变出房子，房子是一样的，但生活用品之类的，都是不管的。谁住谁负责添置。</p><p>每一个镜像可以变出一种房子。那么，我可以有多个镜像呀！</p><p>也就是说，我盖了一个欧式别墅，生成了镜像。另一个哥们可能盖了一个中国四合院，也生成了镜像。还有哥们，盖了一个非洲茅草屋，也生成了镜像。。。</p><p>这么一来，我们可以交换镜像，你用我的，我用你的，岂不是很爽？<br><img src="https://pic4.zhimg.com/80/v2-b2b6248eeac508d5a9ad1c7fbf6cb1ef_720w.jpg"></p><p>于是乎，就变成了一个大的公共仓库。负责对Docker镜像进行管理的，是Docker Registry服务（类似仓库管理员）。</p><p>不是任何人建的任何镜像都是合法的。万一有人盖了一个有问题的房子呢？所以，Docker Registry服务对镜像的管理是非常严格的。</p><p>最常使用的Registry公开服务，是官方的Docker Hub，这也是默认的Registry，并拥有大量的高质量的官方镜像。</p><p>好了，说完了Docker，我们再把目光转向K8S。</p><p>就在Docker容器技术被炒得热火朝天之时，大家发现，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。</p><p>于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。</p><p>就在这个时候，K8S出现了。K8S，就是基于容器的集群管理平台，它的全称，是kubernetes。<br><img src="https://pic3.zhimg.com/80/v2-fce2a94afe63f3a6521b2efcd5bffa12_720w.jpg"></p><p>Kubernetes这个单词来自于希腊语，含义是舵手或领航员。K8S是它的缩写，用“8”字替代了“ubernete”这8个字符。</p><p>和Docker不同，K8S的创造者，是众人皆知的行业巨头——Google。然而，K8S并不是一件全新的发明。它的前身，是Google自己捣鼓了十多年的Borg系统。</p><p>K8S是2014年6月由Google公司正式公布出来并宣布开源的。</p><p>同年7月，微软、Red Hat、IBM、Docker、CoreOS、Mesosphere和Saltstack等公司，相继加入K8S。之后的一年内，VMware、HP、Intel等公司，也陆续加入。</p><p>2015年7月，Google正式加入OpenStack基金会。与此同时，Kuberentes v1.0正式发布。</p><p>目前，kubernetes的版本已经发展到V1.13。</p><p>K8S的架构，略微有一点复杂，我们简单来看一下。</p><p>一个K8S系统，通常称为一个K8S集群（Cluster）。</p><p>这个集群主要包括两个部分：</p><ul><li>一个Master节点（主节点）</li><li>一群Node节点（计算节点）<br><img src="https://pic4.zhimg.com/80/v2-466804fc47bd2e939e0413d9c32170af_720w.jpg"></li></ul><p>一看就明白：Master节点主要还是负责管理和控制。Node节点是工作负载节点，里面是具体的容器。</p><p>深入来看这两种节点。</p><p>首先是Master节点。<br><img src="https://pic2.zhimg.com/80/v2-7fa63b292368c8f21bd4582861a6983d_720w.jpg"></p><ul><li><p>Master节点包括API Server、Scheduler、Controller manager、etcd。</p></li><li><p>API Server是整个系统的对外接口，供客户端和其它组件调用，相当于“营业厅”。</p></li><li><p>Scheduler负责对集群内部的资源进行调度，相当于“调度室”。</p></li><li><p>Controller manager负责管理控制器，相当于“大总管”。</p></li></ul><p>然后是Node节点。<br><img src="https://pic4.zhimg.com/80/v2-8cb338cd8923fa0e6857f45facc8f00f_720w.jpg"></p><p>Node节点包括Docker、kubelet、kube-proxy、Fluentd、kube-dns（可选），还有就是Pod。</p><p>Pod是Kubernetes最基本的操作单元。一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。</p><p>除了Pod之外，K8S还有一个Service的概念，一个Service可以看作一组提供相同服务的Pod的对外访问接口。这段不太好理解，跳过吧。</p><ul><li><p>Docker，不用说了，创建容器的。</p></li><li><p>Kubelet，主要负责监视指派到它所在Node上的Pod，包括创建、修改、监控、删除等。</p></li><li><p>Kube-proxy，主要负责为Pod对象提供代理。</p></li><li><p>Fluentd，主要负责日志收集、存储与查询。</p></li></ul><p>是不是有点懵？唉，三言两语真的很难讲清楚，继续跳过吧。</p><p>Docker和K8S都介绍完了，然而文章并没有结束。</p><p>接下来的部分，是写给核心网工程师甚至所有通信工程师看的。</p><p>从几十年前的1G，到现在的4G，再到将来的5G，移动通信发生了翻天覆地的变化，核心网亦是如此。</p><p>但是，如果你仔细洞察这些变化，会发现，所谓的核心网，其实本质上并没有发生改变，无非就是很多的服务器而已。不同的核心网网元，就是不同的服务器，不同的计算节点。</p><p>变化的，是这些“服务器”的形态和接口：形态，从机柜单板，变成机柜刀片，从机柜刀片，变成X86通用刀片服务器；接口，从中继线缆，变成网线，从网线，变成光纤。</p><p>就算变来变去，还是服务器，是计算节点，是CPU。</p><p>既然是服务器，那么就势必会和IT云计算一样，走上虚拟化的道路。毕竟，虚拟化有太多的优势，例如前文所说的低成本、高利用率、充分灵活、动态调度，等等。</p><p>前几年，大家以为虚拟机是核心网的终极形态。目前看来，更有可能是容器化。这几年经常说的NFV（网元功能虚拟化），也有可能改口为NFC（网元功能容器化）。</p><p>以VoLTE为例，如果按以前2G/3G的方式，那需要大量的专用设备，分别充当EPC和IMS的不同网元。</p><p><img src="https://pic2.zhimg.com/80/v2-db0d325f60de323d1346d9d4e0eab1bd_720w.jpg" alt="VoLTE相关的网元"></p><p>而采用容器之后，很可能只需要一台服务器，创建十几个容器，用不同的容器，来分别运行不同网元的服务程序。<br><img src="https://pic1.zhimg.com/80/v2-ebbe757bef45be1ecde8827bb2e1c0bc_720w.jpg"></p><p>这些容器，随时可以创建，也可以随时销毁。还能够在不停机的情况下，随意变大，随意变小，随意变强，随意变弱，在性能和功耗之间动态平衡。</p><p>简直完美！</p><p>5G时代，核心网采用微服务架构，也是和容器完美搭配——单体式架构（Monolithic）变成微服务架构（Microservices），相当于一个全能型变成N个专能型。每个专能型，分配给一个隔离的容器，赋予了最大程度的灵活。<br><img src="https://pic2.zhimg.com/80/v2-3d2ac15aaf388e710111a1a8ffcaf7b1_720w.jpg" alt="精细化分功"></p><p>按照这样的发展趋势，在移动通信系统中，除了天线，剩下的部分都有可能虚拟化。核心网是第一个，但不是最后一个。虚拟化之后的核心网，与其说属于通信，实际上更应该归为IT。核心网的功能，只是容器中普通一个软件功能而已。</p><p>至于说在座的各位核心网工程师，恭喜你们，马上就要成功转型啦！<br><img src="https://pic3.zhimg.com/80/v2-c4b78f1348d2a1d545d078911957824e_720w.jpg">a<br>喜欢的朋友欢迎上知乎关注原博主枣君的微信公众号：鲜枣课堂</p>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装MySQL5.7没设置密码解决方法</title>
    <link href="/blog/2021/09/20/%E5%AE%89%E8%A3%85MySQL5-7%E6%B2%A1%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/blog/2021/09/20/%E5%AE%89%E8%A3%85MySQL5-7%E6%B2%A1%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>我在WSL的CentOS7系统中安装MySQL5.7后发现全程都没设置密码</p><blockquote><p>为了加强安全性，MySQL5.7为root用户随机生成了一个密码，在<code>error log</code>中，关于<code>error log</code>的位置，如果安装的是RPM包，则默认是<code>/var/log/mysqld.log</code>。<br>只有启动过一次mysql才可以查看临时密码</p></blockquote><p>执行下面的代码查看</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">grep &#x27;temporary password&#x27; /var/log/mysqld.log<br></code></pre></td></tr></table></figure><p>结果如下图<br><img src="https://img-blog.csdnimg.cn/img_convert/7832137af22e79856995f506ee111073.png"><br>可以看到我的临时密码为SC4ef;/l*sZa<br>然后用root登陆MySQL：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -uroot -p<br></code></pre></td></tr></table></figure><p>输入密码登陆成功<br>再修改密码为123456，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;<br></code></pre></td></tr></table></figure><p>如果密码设置太简单出现以下的提示<br><code>ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</code><br>如何解决呢？ 这里直接提供解决方案文末有详细的说明</p><p>必须修改两个全局参数：<br>首先，修改validate_password_policy参数的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set global validate_password_policy=0;    <br></code></pre></td></tr></table></figure><p>再修改密码的长度</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">set global validate_password_length=1;<br></code></pre></td></tr></table></figure><p>再次执行修改密码就可以了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;<br></code></pre></td></tr></table></figure><p>授权其他机器登陆</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">GRANT ALL PRIVILEGES ON *.* TO &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;mypassword&#x27; WITH GRANT OPTION;<br><br>FLUSH  PRIVILEGES;<br></code></pre></td></tr></table></figure><blockquote><p>原文链接：<a href="https://blog.csdn.net/zyw_java/article/details/70949596">Centos7.3 安装Mysql5.7并修改初始密码_酷玩时刻-By Javen-CSDN博客</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL的CentOS7报错Failed to get D-Bus connection: Operation not permitted解决办法</title>
    <link href="/blog/2021/09/20/WSL%E7%9A%84CentOS7%E6%8A%A5%E9%94%99Failed-to-get-D-Bus-connection-Operation-not-permitted%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/blog/2021/09/20/WSL%E7%9A%84CentOS7%E6%8A%A5%E9%94%99Failed-to-get-D-Bus-connection-Operation-not-permitted%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>WSL的CentOS7使用systemctl和service命令时报错<code>Failed to get D-Bus connection: Operation not permitted</code>,<br>解决办法是更换systemctl文件<br>首先备份systemctl文件</p><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">mv /usr/bin/systemctl /usr/bin/systemctl.old<br></code></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl https://raw.githubusercontent.com/gdraheim/docker-systemctl-replacement/master/files/docker/systemctl.py &gt; /usr/bin/systemctl<br></code></pre></td></tr></table></figure><p>或者直接打开这个网站<a href="https://raw.githubusercontent.com/gdraheim/docker-systemctl-replacement/master/files/docker/systemctl.py">https://raw.githubusercontent.com/gdraheim/docker-systemctl-replacement/master/files/docker/systemctl.py</a>，将页面的所有内容复制，再使用vim打开systemctl文件并粘贴进去保存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /usr/bin/systemctl<br></code></pre></td></tr></table></figure><p>可能会出现卡顿<br>最后执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +x /usr/bin/systemctl<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>CentOS7</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS7安装MySQL5.7</title>
    <link href="/blog/2021/09/20/CentOS7%E5%AE%89%E8%A3%85MySQL5-7/"/>
    <url>/blog/2021/09/20/CentOS7%E5%AE%89%E8%A3%85MySQL5-7/</url>
    
    <content type="html"><![CDATA[<h3 id="1-下载MySQL安装包"><a href="#1-下载MySQL安装包" class="headerlink" title="1.下载MySQL安装包"></a>1.下载MySQL安装包</h3> <figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm<br></code></pre></td></tr></table></figure><p>安装MySQL源<br> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y localinstall mysql57-community-release-el7-11.noarch.rpm <br></code></pre></td></tr></table></figure></p><h3 id="2-在线安装MySQL"><a href="#2-在线安装MySQL" class="headerlink" title="2.在线安装MySQL"></a>2.在线安装MySQL</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install mysql-community-server<br></code></pre></td></tr></table></figure><h3 id="3-启动MySQL服务"><a href="#3-启动MySQL服务" class="headerlink" title="3.启动MySQL服务"></a>3.启动MySQL服务</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start mysqld<br></code></pre></td></tr></table></figure><p>如果是WSL的CentOS7的话可能会报错：<code>Failed to get D-Bus connection: Operation not permitted</code><br>解决办法：<a href="https://blog.csdn.net/weixin_44294408/article/details/120340885">WSL的CentOS7报错Failed to get D-Bus connection: Operation not permitted解决办法</a></p><h3 id="4-设置MySQL开机自启"><a href="#4-设置MySQL开机自启" class="headerlink" title="4.设置MySQL开机自启"></a>4.设置MySQL开机自启</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl enable mysqld<br>systemctl daemon-reload<br></code></pre></td></tr></table></figure><p>###5.设置root登陆密码<br>这时候你会发现全程都未设置root帐号和密码<br>设置root密码方法：<a href="https://blog.csdn.net/weixin_44294408/article/details/120340860">安装MySQL5.7没设置密码解决方法</a></p><blockquote><p>原文：<a href="https://blog.csdn.net/EB_NUM/article/details/105425622">【centos7 + MySQL5.7 安装】centos7 安装MySQL5.7_宇风-飞扬 的博客-CSDN博客_centos安装mysql5.7</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>CentOS7</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>CentOS7</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS7配置阿里源</title>
    <link href="/blog/2021/09/20/CentOS7%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E6%BA%90/"/>
    <url>/blog/2021/09/20/CentOS7%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-备份原来的文件"><a href="#1-备份原来的文件" class="headerlink" title="1.备份原来的文件"></a>1.备份原来的文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak<br></code></pre></td></tr></table></figure><h2 id="2-下载阿里云源文件"><a href="#2-下载阿里云源文件" class="headerlink" title="2.下载阿里云源文件"></a>2.下载阿里云源文件</h2><p>用该命令下载阿里云源文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo<br></code></pre></td></tr></table></figure><p>如果下载成功直接看第三步</p><p>如果显示wget: command not found,就执行下面的命令安装wget</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install wget<br></code></pre></td></tr></table></figure><p>安装成功后再执行上面的下载命令</p><p>如果安装失败<br>就在本机的win10系统上浏览器直接访问<a href="http://mirrors.aliyun.com/repo/Centos-7.repo">http://mirrors.aliyun.com/repo/Centos-7.repo</a>下载centos7的源文件<br>假如下载到E盘的Downloads文件夹，再将该文件移动到/etc/yum.repos.d下，我是在WSL中操作，因此直接执行下面命令<br><code>mv /mnt/E/Dwonloads/Centos-7.repo /etc/yum.repos.d/CentOS-Base.repo</code></p><h2 id="3-分别执行yum源更新命令"><a href="#3-分别执行yum源更新命令" class="headerlink" title="3.分别执行yum源更新命令"></a>3.分别执行yum源更新命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum clean all <br>yum makecache<br>yum update<br></code></pre></td></tr></table></figure><p>##4.查看源列表是否更换成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum repolist<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>CentOS7</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始在云服务器搭建Hexo个人博客</title>
    <link href="/blog/2021/09/20/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/blog/2021/09/20/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%9C%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BAHexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="1-购买服务器"><a href="#1-购买服务器" class="headerlink" title="1.购买服务器"></a>1.购买服务器</h3><p>首先需要有服务器，也可以在github pages或者gitee pages上部署，我服务器安装的是centos7.6系统；接下来是选择博客框架，看了网上相关推荐和教程，我最终决定用Hexo来搭建博客</p><h3 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2.安装Hexo"></a>2.安装Hexo</h3><p>因为Hexo依赖node.js，因此推荐安装nvm来管理node.js版本</p><ul><li><p>安装nvm<br>  <a href="https://hub.fastgit.org/coreybutler/nvm-windows/releases">点此下载nvm</a>或者直接执行下面这行命令(当前最新版为0.38)</p>  <figure class="highlight awk"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs awk">wget -qO- https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/nvm-sh/</span>nvm<span class="hljs-regexp">/v0.38.0/i</span>nstall.sh | bash  <span class="hljs-comment">##下载并安装nvm</span><br><br>source ~/.bashrc    <br></code></pre></td></tr></table></figure><p>  最后执行<code>nvm version</code>看到显示了如<code>v16.9.1</code>类似的版本号则为安装成功</p></li><li><p>安装node.js<br>  先后执行以下命令</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nvm</span> install node  ##安装最新版node.js，当前最新版本为v<span class="hljs-number">16</span>.<span class="hljs-number">9</span>.<span class="hljs-number">1</span><br><br><span class="hljs-attribute">nvm</span> use v<span class="hljs-number">16</span>.<span class="hljs-number">9</span>.<span class="hljs-number">1</span>  ##切换到该node版本<br></code></pre></td></tr></table></figure></li><li><p>安装Git</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake">Windows：下载并安装 git.<br>Mac：使用 Homebrew, MacPorts 或者下载 安装程序。<br>Linux (Ubuntu, Debian)：sudo apt-get <span class="hljs-keyword">install</span> git-core<br>Linux (Fedora, Red Hat, CentOS)：sudo yum <span class="hljs-keyword">install</span> git-core<br></code></pre></td></tr></table></figure></li><li><p>安装Hexo</p>  <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>  创建存放博客文件的目录</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir <span class="hljs-regexp">/root/</span>hexo<br></code></pre></td></tr></table></figure><p>  初始化</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">hexo init <span class="hljs-regexp">/root/</span>hexo<br></code></pre></td></tr></table></figure><p>  然后进入该目录，安装依赖</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/root/</span>hexo<br><br>npm i<br></code></pre></td></tr></table></figure><p>  则会得到这样的目录：</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle">├── _config.yml<br>├── <span class="hljs-keyword">package</span>.json<br>├── scaffolds<br>├── <span class="hljs-keyword">source</span><br>|   └── _posts<br>└── themes<br></code></pre></td></tr></table></figure><p>   然后执行<code>hexo -g</code>生成静态文件<br>   然后自己选择一个自己喜欢的<code>hexo</code>主题放进<code>themes</code>文件夹中配置好，配置主题的教程这里就不放了，网上一堆。</p><p>   再执行</p>   <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p> 就能在浏览器中输入<code>xxxx:4000</code>就能访问网站了<br>  ps：<code>其中xxxx指服务器的ip，hexo的默认端口应该是4000</code></p><h3 id="3-安装并配置nginx"><a href="#3-安装并配置nginx" class="headerlink" title="3. 安装并配置nginx"></a>3. 安装并配置nginx</h3></li><li><p>安装nginx</p><p>  更新yum信息</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yum update</span><br></code></pre></td></tr></table></figure><p>  下载nginx</p>  <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> nginx<br></code></pre></td></tr></table></figure></li><li><p>配置nginx</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/nginx.conf.  /</span><span class="hljs-regexp">/打开nginx的配置文件</span><br></code></pre></td></tr></table></figure><p>  可以看到以下内容，</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">## For more information on configuration, see:</span><br><span class="hljs-comment">#   * Official English Documentation: http://nginx.org/en/docs/</span><br><span class="hljs-comment">#   * Official Russian Documentation: http://nginx.org/ru/docs/</span><br><br>user root;   <span class="hljs-regexp">//</span>第五行这里改为root<br>-------------------------------分 割 线------------------------------------------<br> server &#123;<br>       listen       <span class="hljs-number">80</span>;<br>       listen       [::]:<span class="hljs-number">80</span>;       <br>       server_name  zrgo.top;          <span class="hljs-regexp">//</span>这里如果你有域名就填上你服务器绑定的域名,没有就默认<br>       root         <span class="hljs-regexp">/root/</span>hexo<span class="hljs-regexp">/public;    /</span><span class="hljs-regexp">/这里填你Hexo中blog的html文件存放地址</span><br></code></pre></td></tr></table></figure><p>  重启nginx服务</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nginx -s reload</span><br></code></pre></td></tr></table></figure><p>  现在直接在浏览器中输入你的域名或者服务器ip地址就能看到你的博客网站了！</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>CentOS7</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
